**********************
PowerShell transcript start
Start time: 20251028130929
Username: AMR\cregnier
RunAs User: AMR\cregnier
Configuration Name: 
Machine: CREGNIER-MOBL (Microsoft Windows NT 10.0.22631.0)
Host Application: C:\Program Files\PowerShell\7\pwsh.dll -NoProfile -File .\scripts\run_testmode_wrapper.ps1
Process ID: 42848
PSVersion: 7.5.3
PSEdition: Core
GitCommitId: 7.5.3
OS: Microsoft Windows 10.0.22631
Platform: Win32NT
PSCompatibleVersions: 1.0, 2.0, 3.0, 4.0, 5.0, 5.1, 6.0, 7.0
PSRemotingProtocolVersion: 2.3
SerializationVersion: 1.1.0.1
WSManStackVersion: 3.0
**********************
Transcript started, output file is C:\Source\Github\powershell-akv-audit\output\testmode_transcript_2025-10-28_13-09-29.txt
BEGIN_TESTMODE_TRANSCRIPT -> C:\Source\Github\powershell-akv-audit\output\testmode_transcript_2025-10-28_13-09-29.txt
[2025-10-28 13:09:30] [INFO]    [DEBUG] Script-level PSBoundParameters: TestMode=True, Limit=1, Verbose=True, SuppressAzureWarnings=True
[2025-10-28 13:09:30] [INFO]    Auto-running Invoke-GapAnalysis with script-level parameters (count: 4)
[2025-10-28 13:09:30] [INFO]    Starting Azure Key Vault Gap Analysis vunreleased
[2025-10-28 13:09:30] [INFO]    Test Mode: True
[2025-10-28 13:09:30] [INFO]    Test Limit: 1 vaults
[2025-10-28 13:09:36] [WARN]    User confirmed removal of run lock for PID 444; removing and continuing
[2025-10-28 13:09:36] [INFO]    Created run lock at: C:\Users\cregnier\AppData\Local\Temp\akv_gap_analysis_running.lock (PID: 42848)
[2025-10-28 13:09:36] [INFO]    Effective parameters: TestMode=True Limit=1 UseParallelProcessing=False MaxParallelJobs=4 Resume=False
[2025-10-28 13:09:39] [SUCCESS] Successfully authenticated as: curtus.regnier@intel.com
[2025-10-28 13:09:39] [INFO]    Discovering accessible subscriptions...
[2025-10-28 13:09:39] [DEBUG]   About to call Get-AzSubscription to discover accessible subscriptions
[2025-10-28 13:09:42] [INFO]    Found 783 accessible subscription(s)
[2025-10-28 13:09:42] [INFO]    Analyzing subscription: 1ci-preprod-metrics (dc8b9d9c-0cf9-446c-9177-12921182f54a)
[2025-10-28 13:09:42] [INFO]    Discovering Key Vaults in subscription dc8b9d9c-0cf9-446c-9177-12921182f54a...
[2025-10-28 13:09:42] [DEBUG]   Setting Az context to subscription: dc8b9d9c-0cf9-446c-9177-12921182f54a (Set-AzContext)
[2025-10-28 13:09:45] [DEBUG]   Listing Key Vaults in subscription dc8b9d9c-0cf9-446c-9177-12921182f54a via Get-AzKeyVault (with timeout)
[2025-10-28 13:09:45] [INFO]    [DEBUG] Starting background job for Get-AzKeyVault with timeout 60s
[2025-10-28 13:09:45] [INFO]    [DEBUG] Started job Id=1 for Get-AzKeyVault
[2025-10-28 13:09:50] [INFO]    Found 2 Key Vaults in subscription dc8b9d9c-0cf9-446c-9177-12921182f54a
[2025-10-28 13:09:50] [INFO]    Test mode: Limited to 1 vaults in this subscription
[2025-10-28 13:09:50] [INFO]    Assessing Azure platform integration for subscription dc8b9d9c-0cf9-446c-9177-12921182f54a...
[2025-10-28 13:10:09] [INFO]    Found 80 Key Vault related policies in subscription 1ci-preprod-metrics
PS>TerminatingError(): "The pipeline has been stopped."
[2025-10-28 13:11:10] [DEBUG]   Function App discovery skipped for subscription dc8b9d9c-0cf9-446c-9177-12921182f54a (use -IncludeFunctionApps to enable)
[2025-10-28 13:11:10] [INFO]    Analyzing Key Vault: kv-adx-access
[2025-10-28 13:11:10] [INFO]    [DEBUG] Starting background job for Get-AzDiagnosticSetting with timeout 30s
[2025-10-28 13:11:11] [INFO]    [DEBUG] Started job Id=3 for Get-AzDiagnosticSetting
[2025-10-28 13:11:39] [INFO]    [DEBUG] Finished Analyze-KeyVault for kv-adx-access in 29.18s
[2025-10-28 13:11:39] [INFO]    Finished analysis of kv-adx-access - persisting marker and checkpoint
PS>TerminatingError(Mark-Vault-Processed): "Cannot bind argument to parameter 'JsonFilePath' because it is an empty string."
[2025-10-28 13:11:39] [INFO]    Completed analysis of kv-adx-access - Score: 86%, Risk: Medium
[2025-10-28 13:11:39] [INFO]    Test mode limit (1) reached, stopping analysis
[2025-10-28 13:11:39] [INFO]    Exporting CSV results...
[2025-10-28 13:11:39] [INFO]    Analysis results count: 1
[2025-10-28 13:11:39] [INFO]    Canonical QuickWins unique titles: 1
[2025-10-28 13:11:39] [INFO]    Starting enrichment of 1 results with Collect-ExtraAzData
[2025-10-28 13:11:39] [INFO]    Enriching vault: kv-adx-access (/subscriptions/dc8b9d9c-0cf9-446c-9177-12921182f54a/resourceGroups/rg-1ci-metrics-data-analytics/providers/Microsoft.KeyVault/vaults/kv-adx-access)
[2025-10-28 13:11:39] [INFO]    [DEBUG] Collect-ExtraAzData start for /subscriptions/dc8b9d9c-0cf9-446c-9177-12921182f54a/resourceGroups/rg-1ci-metrics-data-analytics/providers/Microsoft.KeyVault/vaults/kv-adx-access
[2025-10-28 13:11:39] [DEBUG]   Collect-ExtraAzData: calling Get-AzResource for /subscriptions/dc8b9d9c-0cf9-446c-9177-12921182f54a/resourceGroups/rg-1ci-metrics-data-analytics/providers/Microsoft.KeyVault/vaults/kv-adx-access
[2025-10-28 13:11:41] [DEBUG]   Collect-ExtraAzData: calling Get-AzResourceLock for /subscriptions/dc8b9d9c-0cf9-446c-9177-12921182f54a/resourceGroups/rg-1ci-metrics-data-analytics/providers/Microsoft.KeyVault/vaults/kv-adx-access
PS>TerminatingError(Get-AzResourceLock): "The running command stopped because the preference variable "ErrorActionPreference" or common parameter is set to Stop: The Id '/subscriptions/dc8b9d9c-0cf9-446c-9177-12921182f54a/resourceGroups/rg-1ci-metrics-data-analytics/providers/Microsoft.KeyVault/vaults/kv-adx-access' does not belong to a lock."
[2025-10-28 13:11:41] [INFO]    [DEBUG] Starting background job for Get-AzDiagnosticSetting with timeout 30s
[2025-10-28 13:11:41] [INFO]    [DEBUG] Started job Id=5 for Get-AzDiagnosticSetting
[2025-10-28 13:11:54] [DEBUG]   Attempting Get-AzKeyVault (timeout 30s) for kv-adx-access in RG rg-1ci-metrics-data-analytics
[2025-10-28 13:11:54] [INFO]    [DEBUG] Starting background job for Get-AzKeyVault with timeout 30s
[2025-10-28 13:11:54] [INFO]    [DEBUG] Started job Id=7 for Get-AzKeyVault
PS>TerminatingError(Get-AzADUser): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADServicePrincipal): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADUser): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADServicePrincipal): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADUser): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADServicePrincipal): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADUser): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADServicePrincipal): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADUser): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADServicePrincipal): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADUser): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADServicePrincipal): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADUser): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADServicePrincipal): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADUser): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADServicePrincipal): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADUser): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADServicePrincipal): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADUser): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADServicePrincipal): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADUser): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADServicePrincipal): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADUser): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADServicePrincipal): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADUser): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADServicePrincipal): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADUser): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADServicePrincipal): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADUser): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADServicePrincipal): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADUser): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADServicePrincipal): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADUser): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADServicePrincipal): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADUser): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADServicePrincipal): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADUser): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADServicePrincipal): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADUser): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADServicePrincipal): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADUser): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADServicePrincipal): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADUser): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADServicePrincipal): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADUser): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADServicePrincipal): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADUser): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADServicePrincipal): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADUser): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADServicePrincipal): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADUser): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADServicePrincipal): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADUser): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADServicePrincipal): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADUser): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADServicePrincipal): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADUser): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADServicePrincipal): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADUser): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADServicePrincipal): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADUser): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADServicePrincipal): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADUser): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADServicePrincipal): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADUser): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADServicePrincipal): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADUser): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADServicePrincipal): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADUser): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADServicePrincipal): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADUser): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADServicePrincipal): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADUser): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADServicePrincipal): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADUser): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADServicePrincipal): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADUser): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADServicePrincipal): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADUser): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADServicePrincipal): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADUser): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADServicePrincipal): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADUser): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADServicePrincipal): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADUser): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADServicePrincipal): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADUser): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADServicePrincipal): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADUser): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADServicePrincipal): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADUser): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADServicePrincipal): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADUser): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADServicePrincipal): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADUser): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADServicePrincipal): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADUser): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADServicePrincipal): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADUser): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADServicePrincipal): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADUser): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADServicePrincipal): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADUser): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADServicePrincipal): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADUser): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADServicePrincipal): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADUser): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADServicePrincipal): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADUser): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADServicePrincipal): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADUser): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADServicePrincipal): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADUser): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADServicePrincipal): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADUser): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADServicePrincipal): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADUser): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADServicePrincipal): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADUser): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADServicePrincipal): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADUser): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADServicePrincipal): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADUser): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADServicePrincipal): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADUser): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADServicePrincipal): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADUser): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADServicePrincipal): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADUser): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADServicePrincipal): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADUser): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADServicePrincipal): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADUser): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADServicePrincipal): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADUser): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADServicePrincipal): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADUser): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADServicePrincipal): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADUser): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADServicePrincipal): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADUser): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADServicePrincipal): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADUser): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADServicePrincipal): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADUser): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADServicePrincipal): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADUser): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADServicePrincipal): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADUser): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADServicePrincipal): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADUser): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADServicePrincipal): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADUser): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADServicePrincipal): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADUser): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADServicePrincipal): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADUser): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADServicePrincipal): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADUser): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADServicePrincipal): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADUser): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADServicePrincipal): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADUser): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADServicePrincipal): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADUser): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADServicePrincipal): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADUser): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADServicePrincipal): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADUser): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADServicePrincipal): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADUser): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADServicePrincipal): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADUser): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADServicePrincipal): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADUser): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADServicePrincipal): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADUser): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADServicePrincipal): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADUser): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADServicePrincipal): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADUser): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADServicePrincipal): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADUser): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADServicePrincipal): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADUser): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADServicePrincipal): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADUser): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADServicePrincipal): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADUser): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADServicePrincipal): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADUser): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADServicePrincipal): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADUser): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADServicePrincipal): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADUser): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADServicePrincipal): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADUser): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADServicePrincipal): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADUser): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADServicePrincipal): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADUser): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADServicePrincipal): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADUser): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADServicePrincipal): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADUser): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADServicePrincipal): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADUser): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADServicePrincipal): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADUser): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADServicePrincipal): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADUser): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADServicePrincipal): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADUser): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADServicePrincipal): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADUser): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADServicePrincipal): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADUser): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADServicePrincipal): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADUser): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADServicePrincipal): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADUser): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADServicePrincipal): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADUser): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADServicePrincipal): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADUser): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADServicePrincipal): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADUser): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADServicePrincipal): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADUser): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADServicePrincipal): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADUser): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADServicePrincipal): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADUser): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADServicePrincipal): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADUser): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADServicePrincipal): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADUser): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADServicePrincipal): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADUser): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADServicePrincipal): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADUser): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADServicePrincipal): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADUser): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADServicePrincipal): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADUser): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADServicePrincipal): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADUser): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADServicePrincipal): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADUser): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADServicePrincipal): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADUser): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADServicePrincipal): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADUser): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADServicePrincipal): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADUser): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADServicePrincipal): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADUser): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADServicePrincipal): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADUser): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADServicePrincipal): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADUser): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADServicePrincipal): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADUser): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADServicePrincipal): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADUser): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADServicePrincipal): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADUser): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADServicePrincipal): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADUser): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADServicePrincipal): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADUser): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
>> TerminatingError(Get-AzADServicePrincipal): "Cannot bind argument to parameter 'ObjectId' because it is an empty string."
[2025-10-28 13:12:03] [DEBUG]   Listing secrets for vault kv-adx-access via Get-AzKeyVaultSecret (timeout 30s)
[2025-10-28 13:12:03] [INFO]    [DEBUG] Starting background job for Get-AzKeyVaultSecret with timeout 30s
[2025-10-28 13:12:03] [INFO]    [DEBUG] Started job Id=9 for Get-AzKeyVaultSecret
PS>TerminatingError(): "The running command stopped because the preference variable "ErrorActionPreference" or common parameter is set to Stop: Operation returned an invalid status code 'Forbidden'
Code: Forbidden
Message: Public network access is disabled and request is not from a trusted service nor via an approved private link.
Caller: appid=1950a258-227b-4e31-a9cf-717495945fc2;oid=0ec2ca67-dcd8-480a-93ac-98ab3a9505c6;iss=https://sts.windows.net/46c98d88-e344-4ed4-8496-4ed7712e255d/
Vault: kv-adx-access;location=westus"
[2025-10-28 13:12:08] [DEBUG]   Listing keys for vault kv-adx-access via Get-AzKeyVaultKey (timeout 30s)
[2025-10-28 13:12:08] [INFO]    [DEBUG] Starting background job for Get-AzKeyVaultKey with timeout 30s
[2025-10-28 13:12:08] [INFO]    [DEBUG] Started job Id=11 for Get-AzKeyVaultKey
PS>TerminatingError(): "The running command stopped because the preference variable "ErrorActionPreference" or common parameter is set to Stop: Public network access is disabled and request is not from a trusted service nor via an approved private link.
Caller: appid=1950a258-227b-4e31-a9cf-717495945fc2;oid=0ec2ca67-dcd8-480a-93ac-98ab3a9505c6;iss=https://sts.windows.net/46c98d88-e344-4ed4-8496-4ed7712e255d/
Vault: kv-adx-access;location=westus
Status: 403 (Forbidden)
ErrorCode: Forbidden

Content:
{"error":{"code":"Forbidden","message":"Public network access is disabled and request is not from a trusted service nor via an approved private link.\r\nCaller: appid=1950a258-227b-4e31-a9cf-717495945fc2;oid=0ec2ca67-dcd8-480a-93ac-98ab3a9505c6;iss=https://sts.windows.net/46c98d88-e344-4ed4-8496-4ed7712e255d/\r\nVault: kv-adx-access;location=westus","innererror":{"code":"ForbiddenByConnection"}}}

Headers:
Cache-Control: no-cache
Pragma: no-cache
x-ms-keyvault-region: westus
x-ms-client-request-id: 977ab6fd-c151-4147-a0c0-40cea5b8306e
x-ms-request-id: 4de6025f-6253-4c12-af7c-49587220e8df
x-ms-keyvault-service-version: 1.9.2791.2
x-ms-keyvault-network-info: conn_type=Ipv4;addr=174.254.51.155;act_addr_fam=InterNetwork;
x-ms-keyvault-rbac-assignment-id: REDACTED
X-Content-Type-Options: REDACTED
Strict-Transport-Security: REDACTED
Date: Tue, 28 Oct 2025 17:12:13 GMT
Content-Type: application/json; charset=utf-8
Expires: -1
Content-Length: 399
"
[2025-10-28 13:12:14] [INFO]    [DEBUG] Collect-ExtraAzData completed for /subscriptions/dc8b9d9c-0cf9-446c-9177-12921182f54a/resourceGroups/rg-1ci-metrics-data-analytics/providers/Microsoft.KeyVault/vaults/kv-adx-access in 34.54s
[2025-10-28 13:12:14] [INFO]    Enriched vault: kv-adx-access - done
[2025-10-28 13:12:14] [INFO]    Enrichment completed for 1 vault(s) in 34.57s
[2025-10-28 13:12:14] [INFO]    Starting Build-MasterCsvRecord for 1 enriched results
[2025-10-28 13:12:14] [INFO]    Building CSV record for: kv-adx-access
[2025-10-28 13:12:14] [INFO]    Built CSV record for: kv-adx-access
[2025-10-28 13:12:14] [INFO]    Build-MasterCsvRecord completed for 2 records in 0.26s
[2025-10-28 13:12:14] [DEBUG]   Final coercion timeout set to 60s (heartbeat 5s)
[2025-10-28 13:12:14] [DEBUG]   Final coercion: filtered flattenedResults 2 -> 1 (dropped non-object/empty rows)
[2025-10-28 13:12:14] [WARN]    Running final coercion synchronously in-process (shouldForceInProcess=True)
[2025-10-28 13:12:14] [DEBUG]   Disabling per-vault JSON writes for in-process final coercion
[2025-10-28 13:12:14] [DEBUG]   [COERCION] Row #1 type=System.Management.Automation.PSCustomObject propCount=1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 VaultName='kv-adx-access'
[2025-10-28 13:12:14] [DEBUG]   [COERCION] Processed props for kv-adx-access: 
Name                           Value
----                           -----
Timestamp                      10/28/2025 13:12:14
SubscriptionId                 dc8b9d9c-0cf9-446c-9177-12921182f54a
SubscriptionName               1ci-preprod-metrics
TenantId                       
VaultName                      kv-adx-access
VaultResourceId                /subscriptions/dc8b9d9c-0cf9-446c-9177-12921182f54a/resourceGroups/rg-1ci-metrics-data-ana…
ResourceGroupName              rg-1ci-metrics-data-analytics
Location                       westus
VaultSku                       
EnableSoftDelete               False
EnablePurgeProtection          False
SoftDeleteRetentionDays        
AccessModel                    RBAC
RbacEnabled                    True
AccessPoliciesCount            0
RoleAssignmentsCount           136
RoleAssignmentsResolved        Owner:;User Access Administrator:;User Access Administrator:;Owner:;User Access Administra…
HasPrivateEndpoints            True
PrivateEndpointIds             
PrivateEndpointCount           0
FirewallEnabled                False
AllowedIps                     
HasDiagnostics                 True
DiagnosticSettings             
DiagnosticDestinations         
SecretsCount                   0
CertificatesCount              0
KeysCount                      0
TotalAssets                    0
RecentlyRotatedCount           0
ManualRotationNeeded           0
NeverRotated                   0
SecurityGapsCount              2
SecurityGapsSummary            Critical: Soft delete not enabled; Medium: Purge protection not enabled
QuickWinsCount                 7
QuickWinsSummary               Enable Soft Delete
ComplianceScore                86
VaultScore                     86
CISComplianceScore             100
NISTComplianceScore            80
ISOComplianceScore             85
MSComplianceScore              80
RiskLevel                      Medium
PolicyCount                    0
PolicyNames                    
ManagedIdentityType            
ManagedIdentityIds             
ManagedIdentityResolved        NotReadable
ResourceLockTypes              
NetworkIpRules                 
NetworkVNetRuleIds             
NetworkDefaultAction           False
NetworkBypass                  False
PublicNetworkAccess            Disabled
PrivateEndpointIdsNormalized   
DiagnosticDestinationNames     Microsoft.EventHub/Namespaces/AuthorizationRules:RootManageSharedAccessKey
DiagnosticDestinationsRaw      /subscriptions/038632dc-f883-45de-9a7a-bd0285faa099/resourceGroups/InfoSecCentralRG/provid…
SkuName                        NotReadable
SecretRotationMostRecent       NotReadable
KeyRotationMostRecent          NotReadable
PermissionIssuesCount          0
Tags                           {}
JsonFilePath                   C:\Users\cregnier\OneDrive - Intel Corporation\Documents\KeyVaultGapAnalysis\VaultJson\dc8…
AccessPoliciesDetails          
AccessPolicies_Permissions_Ke… 
AccessPolicies_Permissions_Se… 
AccessPolicies_Permissions_Ce… 
ProvisioningState              Succeeded
LogAnalyticsWorkspaceIds
[2025-10-28 13:12:14] [ERROR]   [COERCION] Skipped non-hashtable props for kv-adx-access
[2025-10-28 13:12:14] [DEBUG]   Processed vault: kv-adx-access
[2025-10-28 13:12:14] [WARN]    Pre-export parity check failed: canonical unique quick wins (1) != parsed quick wins from CSV data (0)
[2025-10-28 13:12:14] [INFO]    Wrote quick-wins reconciliation to: C:\Users\cregnier\OneDrive - Intel Corporation\Documents\KeyVaultGapAnalysis\quickwins_reconciliation_2025-10-28_13-12-14.csv
[2025-10-28 13:12:14] [INFO]    Starting final CSV export to: C:\Users\cregnier\OneDrive - Intel Corporation\Documents\KeyVaultGapAnalysis\KeyVaultGapAnalysis_2025-10-28_13-09-29.csv
Split-Path: C:\Source\Github\powershell-akv-audit\Get-AKVGapAnalysis.ps1:5866:26
Line |
5866 |  … scriptDir = Split-Path -Path $MyInvocation.MyCommand.Definition -Pare …
     |                ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     | The path 'TestMode = $TestMode }         if ($PSBoundParameters.ContainsKey('Limit')) { $script:Limit = $Limit }         if ($PSBoundParameters.ContainsKey('SubscriptionId')) { $script:SubscriptionId = $SubscriptionId }         if ($PSBoundParameters.ContainsKey('OutputDirectory')) { $script:OutputDirectory = $OutputDirectory; if ($OutputDirectory) { $script:outputDir = $OutputDirectory } }         if ($PSBoundParameters.ContainsKey('SuppressAzureWarnings')) { $script:SuppressAzureWarnings = $SuppressAzureWarnings }         if ($PSBoundParameters.ContainsKey('SingleVault')) { $script:SingleVault = $SingleVault }         if ($PSBoundParameters.ContainsKey('VaultName')) { $script:VaultName = $VaultName }         if ($PSBoundParameters.ContainsKey('SubscriptionName')) { $script:SubscriptionName = $SubscriptionName }         if ($PSBoundParameters.ContainsKey('UseParallelProcessing')) { $script:UseParallelProcessing = $UseParallelProcessing }         if ($PSBoundParameters.ContainsKey('MaxParallelJobs')) { $script:MaxParallelJobs = $MaxParallelJobs }         if ($PSBoundParameters.ContainsKey('Resume')) { $script:Resume = $Resume }         if ($PSBoundParameters.ContainsKey('SuppressModuleWarnings')) { $script:SuppressModuleWarnings = $SuppressModuleWarnings }         if ($PSBoundParameters.ContainsKey('AutoInstallModules')) { $script:AutoInstallModules = $AutoInstallModules }         if ($PSBoundParameters.ContainsKey('DeepCrossReference')) { $script:DeepCrossReference = $DeepCrossReference }     if ($PSBoundParameters.ContainsKey('SimulateInterruptAfter')) { $script:SimulateInterruptAfter = $SimulateInterruptAfter }     if ($PSBoundParameters.ContainsKey('IncludeFunctionApps')) { $script:IncludeFunctionApps = $IncludeFunctionApps }         if ($PSBoundParameters.ContainsKey('AKV_HTML_ONLY')) { $script:AKV_HTML_ONLY = $AKV_HTML_ONLY }         if ($PSBoundParameters.ContainsKey('FinalCoercionTimeoutSeconds')) { $script:FinalCoercionTimeoutSeconds = $FinalCoercionTimeoutSeconds }         if ($PSBoundParameters.ContainsKey('FinalCoercionHeartbeatSeconds')) { $script:FinalCoercionHeartbeatSeconds = $FinalCoercionHeartbeatSeconds }         if ($PSBoundParameters.ContainsKey('AKV_HTML_DATA_PATH')) { $script:AKV_HTML_DATA_PATH = $AKV_HTML_DATA_PATH }         if ($PSBoundParameters.ContainsKey('AKV_HTML_PLATFORM_PATH')) { $script:AKV_HTML_PLATFORM_PATH = $AKV_HTML_PLATFORM_PATH }         if ($PSBoundParameters.ContainsKey('AKV_HTML_OUTPUT_PATH')) { $script:AKV_HTML_OUTPUT_PATH = $AKV_HTML_OUTPUT_PATH }     } catch { $null }      # Normalize and reconcile parameter values so logging and conditional logic     # use a single authoritative local value (handles auto-splatting and script-level calls).     try {         if ($PSBoundParameters -and $PSBoundParameters.ContainsKey('TestMode')) { $TestMode = [bool]$PSBoundParameters['TestMode'] }         elseif ($script:TestMode) { $TestMode = [bool]$script:TestMode }          if ($PSBoundParameters -and $PSBoundParameters.ContainsKey('Limit')) { $Limit = [int]$PSBoundParameters['Limit'] }         elseif ($script:Limit) { $Limit = [int]$script:Limit }          if ($PSBoundParameters -and $PSBoundParameters.ContainsKey('NoRunLock')) { $NoRunLock = [bool]$PSBoundParameters['NoRunLock'] }         elseif ($script:NoRunLock) { $NoRunLock = [bool]$script:NoRunLock }          if ($PSBoundParameters -and $PSBoundParameters.ContainsKey('UseParallelProcessing')) { $UseParallelProcessing = [bool]$PSBoundParameters['UseParallelProcessing'] }         if ($PSBoundParameters -and $PSBoundParameters.ContainsKey('MaxParallelJobs')) { $MaxParallelJobs = [int]$PSBoundParameters['MaxParallelJobs'] }     } catch { }      # Ensure local variables reflect script-level bound parameters (robustness when auto-splatting)     try {         if ($PSBoundParameters -and $PSBoundParameters.ContainsKey('TestMode')) { $TestMode = $PSBoundParameters['TestMode'] }         if ($PSBoundParameters -and $PSBoundParameters.ContainsKey('Limit')) { $Limit = $PSBoundParameters['Limit'] }         if ($PSBoundParameters -and $PSBoundParameters.ContainsKey('UseParallelProcessing')) { $UseParallelProcessing = $PSBoundParameters['UseParallelProcessing'] }         if ($PSBoundParameters -and $PSBoundParameters.ContainsKey('MaxParallelJobs')) { $MaxParallelJobs = $PSBoundParameters['MaxParallelJobs'] }         if ($PSBoundParameters -and $PSBoundParameters.ContainsKey('Resume')) { $Resume = $PSBoundParameters['Resume'] }         if ($PSBoundParameters -and $PSBoundParameters.ContainsKey('OutputDirectory')) { $OutputDirectory = $PSBoundParameters['OutputDirectory']; if ($OutputDirectory) { $script:outputDir = $OutputDirectory } }         if ($PSBoundParameters -and $PSBoundParameters.ContainsKey('NoRunLock')) { $NoRunLock = $PSBoundParameters['NoRunLock'] }     } catch { }      # Prevent re-entrant calls in the same process: if the function is already running,     # bail out early to avoid nested or recursive invocations that interfere with locks.     if ($Force) {         $global:AkvGapAnalysis_InProcessRun = $false         Write-Log "Forced reset of in-process run flag due to -Force parameter" -Level 'WARN'     }      try {         # Test-only bypass: if AKV_FORCE_BYPASS_LOCK=1 in the environment, skip the         # early in-process sentinel check so a controlled test run can proceed even         # while another run previously set the sentinel. This is intentionally         # guarded by an explicit env var to avoid accidental bypass in production.         if ($env:AKV_FORCE_BYPASS_LOCK -eq '1') {             Write-Log "AKV_FORCE_BYPASS_LOCK=1 detected — bypassing in-process sentinel check for test run" -Level 'WARN'         } else {             if ($global:AkvGapAnalysis_InProcessRun) {                 # Capture call stack for diagnostics                 try { $cs = Get-PSCallStack | Out-String -ErrorAction SilentlyContinue } catch { $cs = 'Unable to capture call stack' }                 Write-Log "Invoke-GapAnalysis called while another run is active in this process (PID: $PID) - skipping nested invocation. CallStack: $cs" -Level 'WARN'                 return             }         }         $global:AkvGapAnalysis_InProcessRun = $true     } catch { }      # If the user requested to suppress the noisy Azure module warnings, also     # silence non-critical module discovery warnings to avoid log spam. This     # keeps the UX tidy when -SuppressAzureWarnings is passed at the script     # invocation level (propagated via splatting below).     try {         if ($SuppressAzureWarnings -and -not $SuppressModuleWarnings) { $SuppressModuleWarnings = $true }     } catch { }      Write-Log "Starting Azure Key Vault Gap Analysis v$ScriptVersion" -Level "INFO"     Write-Log "Test Mode: $TestMode" -Level "INFO"     if ($TestMode) { Write-Log "Test Limit: $Limit vaults" -Level "INFO" }      # Record start time for reporting and duration calculations     $script:StartTime = Get-Date      # Lightweight run lock to avoid accidental re-entry: create a lock file when a full     # run starts. Child\HTML-only runner sets AKV_RUN_HTML_ONLY=1 and should not be     # blocked from generating HTML. If a lock already exists and we're not an     # HTML-only runner, exit early to avoid starting a second full analysis.     # Respect explicit opt-out for developers\testing: -NoRunLock skips run-lock creation\inspection.     if ($NoRunLock) {         Write-Log "NoRunLock specified: skipping run-lock creation and inspection. This allows concurrent runs and may cause duplicate work or race conditions. Use only for testing\development. To force a bypass in scripts without changing parameters, set AKV_FORCE_BYPASS_LOCK=1 in the environment." -Level 'WARN'         # still set a canonical RunLockPath variable so other code that references it won't error         $script:RunLockPath = Join-Path -Path $env:TEMP -ChildPath 'akv_gap_analysis_running.lock'     } else {         try {             $script:RunLockPath = Join-Path -Path $env:TEMP -ChildPath 'akv_gap_analysis_running.lock'             # TTL for run lock (seconds). Default 1 hour.             if (-not $global:RunLockTtlSeconds) { $global:RunLockTtlSeconds = 3600 }             $runLockTtl = [int]$global:RunLockTtlSeconds              # Respect a test-only bypass env var that allows forcing a run even when a             # lock file or sentinel exists. This should only be used for short-lived             # test runs and requires an explicit env var to enable.             if ($env:AKV_FORCE_BYPASS_LOCK -eq '1') {                 Write-Log "AKV_FORCE_BYPASS_LOCK=1 detected — bypassing run-lock file checks for test run" -Level 'WARN'             }              if (-not ($env:AKV_FORCE_BYPASS_LOCK -eq '1')) {                 if (-not ($env:AKV_RUN_HTML_ONLY -eq '1' -or ($script:AKV_HTML_ONLY -eq $true))) {                     if (Test-Path $script:RunLockPath) {                         # Try to read lock metadata to determine age                         try {                             $raw = Get-Content -Path $script:RunLockPath -ErrorAction SilentlyContinue -Raw                             $meta = $null                             if ($raw -and $raw.Trim() -ne '') {                                 try { $meta = $raw | ConvertFrom-Json -ErrorAction SilentlyContinue } catch { $meta = $null }                             }                             if ($meta -and $meta.StartedUtc) {                                 # Try ISO-8601 ('o') first, then fall back to a general parse to be tolerant of other formats                                 $started = $null                                 try {                                     $ok = [datetime]::TryParseExact($meta.StartedUtc, 'o', $null, [System.Globalization.DateTimeStyles]::RoundtripKind, [ref]$started)                                     if (-not $ok) {                                         try { $started = [datetime]::Parse($meta.StartedUtc) } catch { $started = $null }                                     }                                 } catch {                                     try { $started = [datetime]::Parse($meta.StartedUtc) } catch { $started = $null }                                 }                                 if ($started) { $age = (Get-Date) - $started } else { $age = $null }                                 if ($age.TotalSeconds -gt $runLockTtl) {                                     Write-Log "Found stale run lock (age: $([math]::Round($age.TotalMinutes,1))m) at $script:RunLockPath - removing stale lock" -Level 'WARN'                                     try { Remove-Item -Path $script:RunLockPath -Force -ErrorAction SilentlyContinue } catch { }                                 } else {                                     if ($age) {                                         # If the lock metadata contains a PID, check whether that process is still running.                                         $lockPid = $meta.PID                                         $proc = $null                                         if ($lockPid) {                                             try { $proc = Get-Process -Id $lockPid -ErrorAction SilentlyContinue } catch { $proc = $null }                                         }                                         if ($lockPid -and -not $proc) {                                             # The recorded PID is not running. Allow an automatic bypass for test\resume flows                                             # or prompt the interactive user to confirm removal. Non-interactive runs will be conservative                                             # and will not remove the lock unless -Resume is provided or the test env var is set.                                             if ($Resume -or ($env:AKV_FORCE_BYPASS_LOCK -eq '1')) {                                                 Write-Log "Run lock at $script:RunLockPath refers to PID $lockPid which is not running; removing lock due to -Resume\AKV_FORCE_BYPASS_LOCK" -Level 'WARN'                                                 try { Remove-Item -Path $script:RunLockPath -Force -ErrorAction SilentlyContinue } catch { }                                             } else {                                                 $confirmed = $false                                                 try {                                                     # Attempt an interactive prompt; if Read-Host fails (non-interactive), fall through to exit.                                                     $prompt = "Detected run lock for PID $lockPid (started $($meta.StartedUtc)) but that process is not running. Remove lock and continue? [y\N]"                                                     $answer = Read-Host -Prompt $prompt                                                     if ($answer -and $answer.Trim().ToUpper().StartsWith('Y')) { $confirmed = $true }                                                 } catch {                                                     # Non-interactive host; cannot prompt. Do not remove lock.                                                     $confirmed = $false                                                 }                                                 if ($confirmed) {                                                     Write-Log "User confirmed removal of run lock for PID $lockPid; removing and continuing" -Level 'WARN'                                                     try { Remove-Item -Path $script:RunLockPath -Force -ErrorAction SilentlyContinue } catch { }                                                 } else {                                                     Write-Log "Run-lock present and user did not confirm removal; exiting to avoid duplicate work." -Level 'WARN'                                                     return                                                 }                                             }                                         } else {                                             if ($age) {                                                 Write-Log "Detected existing run lock ($script:RunLockPath) created by PID $($meta.PID) at $($meta.StartedUtc). Another run appears active — exiting to avoid duplicate work." -Level 'WARN'                                             } else {                                                 Write-Log "Detected existing run lock ($script:RunLockPath) with unparsable StartedUtc ('$($meta.StartedUtc)'). Treating as active and exiting to avoid duplicate work." -Level 'WARN'                                             }                                             return                                         }                                     } else {                                         # Unknown lock contents; be conservative and exit                                         Write-Log "Detected existing run lock ($script:RunLockPath) with unknown metadata. Another run may be active — exiting to avoid duplicate work." -Level 'WARN'                                         return                                     }                                 }                             } else {                                 # Unknown lock contents; be conservative and exit                                 Write-Log "Detected existing run lock ($script:RunLockPath) with unknown metadata. Another run may be active — exiting to avoid duplicate work." -Level 'WARN'                                 return                             }                         } catch {                             Write-Log "Error while inspecting run lock ($script:RunLockPath): $($_.Exception.Message) - exiting to avoid duplicate work" -Level 'WARN'                             return                         }                     }                      # Create a lock file with metadata                     try {                         $lockMeta = [ordered]@{                             PID = $PID                             Owner = $env:USERNAME                             StartedUtc = (Get-Date).ToString('o')                             Command = ($MyInvocation.MyCommand.Definition -as [string])                         }                         $lockMeta | ConvertTo-Json -Depth 4 | Out-File -FilePath $script:RunLockPath -Encoding UTF8 -Force                         # Use INFO level here because Write-Log ValidateSet may not accept DEBUG in some contexts                         Write-Log "Created run lock at: $script:RunLockPath (PID: $PID)" -Level 'INFO'                     } catch {                         Write-Log "Failed to create run lock ($script:RunLockPath): $($_.Exception.Message) - continuing without lock" -Level 'WARN'                     }                 }             }         } catch {             # best-effort: if lock cannot be created or inspected, continue         }     }          # Debug: print canonical effective runtime parameters for visibility (useful when dot-sourced)     try {         $debugParams = [PSCustomObject]@{             TestMode = $TestMode             Limit = $Limit             UseParallelProcessing = $UseParallelProcessing             MaxParallelJobs = $MaxParallelJobs             Resume = $Resume         }         Write-Log ("Effective parameters: TestMode={0} Limit={1} UseParallelProcessing={2} MaxParallelJobs={3} Resume={4}" -f $debugParams.TestMode, $debugParams.Limit, $debugParams.UseParallelProcessing, $debugParams.MaxParallelJobs, $debugParams.Resume) -Level 'INFO'     } catch { }          # If the caller requested suppression of Azure warnings, reduce global         # warning noise for the duration of this run by setting WarningPreference         # to SilentlyContinue. We restore it at the end of the run.         try {             if ($SuppressAzureWarnings) {                 $script:__prevWarningPreference = $WarningPreference                 $WarningPreference = 'SilentlyContinue'             }         } catch { }          # If invoked as HTML-only child via parameter, populate legacy env vars so the         # existing HTML-only branch (which checks $env:AKV_RUN_HTML_ONLY) continues to work.         try {             if ($AKV_HTML_ONLY) {                 Write-Log "HTML-only invocation detected via -AKV_HTML_ONLY; setting legacy env vars for compatibility" -Level 'INFO'                 $env:AKV_RUN_HTML_ONLY = '1'                 if ($AKV_HTML_DATA_PATH) { $env:AKV_HTML_DATA_PATH = $AKV_HTML_DATA_PATH }                 if ($AKV_HTML_PLATFORM_PATH) { $env:AKV_HTML_PLATFORM_PATH = $AKV_HTML_PLATFORM_PATH }                 if ($AKV_HTML_OUTPUT_PATH) { $env:AKV_HTML_OUTPUT_PATH = $AKV_HTML_OUTPUT_PATH }             }         } catch { }      # Prepare a path for a test-mode reservation counter so parallel runspaces can atomically reserve slots     try {         $testCounterPath = Join-Path -Path $outputDir -ChildPath 'testmode_counter.txt'         # Reset counter at run start when starting fresh (not resuming)         if ($TestMode -and -not $Resume) {             try { if (Test-Path $testCounterPath) { Remove-Item -Path $testCounterPath -Force -ErrorAction SilentlyContinue } } catch { }         }     } catch { $testCounterPath = Join-Path -Path $env:TEMP -ChildPath ('testmode_counter_{0}.txt' -f ([guid]::NewGuid().ToString())) }      # Load or initialize checkpoint in memory so Save-Checkpoint-Atomic can use it     try {         $global:checkpoint = Load-Checkpoint         if ($null -eq $global:checkpoint) { $global:checkpoint = @{} }     } catch { $global:checkpoint = @{} }     # Create a worker id for this process (used for parallel-safe incremental CSV temp files)     try { $global:WorkerId = "${env:COMPUTERNAME}_${PID}" } catch { $global:WorkerId = ([guid]::NewGuid().ToString()) }      # Install CTRL-C \ CancelKeyPress handler if available to allow graceful shutdown     try {         if ([console] -and [console].PSIsContainer -ne $null -and ([console] | Get-Member -Name 'CancelKeyPress' -MemberType Event -ErrorAction SilentlyContinue)) {             Register-EngineEvent -SourceIdentifier Console_CancelKeyPress -SupportEvent -Action {                 Write-Log "CTRL-C detected: requesting graceful shutdown..." -Level 'WARN'                 $global:ScriptStopRequested = $true                 try {                     # If a vault is currently in-progress (sequential mode), mark it as processed with a partial marker                     if ($null -ne $global:currentVaultInProgress -and $global:currentVaultInProgress -ne '') {                         try {                             Write-Log "Marking in-progress vault ($global:currentVaultInProgress) as partially processed in checkpoint." -Level 'INFO'                             if (Get-Command -Name Mark-Vault-Processed -ErrorAction SilentlyContinue) {                                 Mark-Vault-Processed -VaultResourceId $global:currentVaultInProgress -JsonFilePath ''                             }                         } catch { }                     }                     # persist the current checkpoint state if any                     if (Get-Command -Name Save-Checkpoint-Atomic -ErrorAction SilentlyContinue) {                         $state = Load-Checkpoint                         Save-Checkpoint-Atomic -State $state                         Write-Log "Checkpoint saved during shutdown." -Level 'INFO'                     }                 } catch { }             } | Out-Null         }     } catch { }      # Initialize authentication     if (!(Initialize-AzureAuthentication)) {         Write-Log "Authentication failed. Exiting." -Level "ERROR"         exit 1     }      # Capture Azure context for parallel processing     $azContext = Get-AzContext     if ($SingleVault) {         Write-Log "Single Vault Mode: Analyzing $VaultName" -Level "INFO"          # Find the subscription containing the vault         $targetSubscription = $null         $foundVault = $null          if ($SubscriptionName) {             # User specified subscription name             Write-Log "Looking up subscription by name: $SubscriptionName (Get-AzSubscription)" -Level 'DEBUG'             $targetSubscription = Get-AzSubscription | Where-Object { $_.Name -eq $SubscriptionName }             if (-not $targetSubscription) {                 Write-Log "Specified subscription '$SubscriptionName' not found" -Level "ERROR"                 exit 1             }         } else {             # Auto-discover subscription containing the vault             Write-Log "Auto-discovering subscription containing vault '$VaultName'..." -Level "INFO"             Write-Log "About to call Get-AzSubscription for auto-discovery" -Level 'DEBUG'             $subscriptionsToCheck = Get-AzSubscription | Where-Object { $_.State -eq 'Enabled' }              foreach ($sub in $subscriptionsToCheck) {                 Write-Log "Setting Az context to subscription $($sub.Name) ($($sub.Id)) before checking for vault" -Level 'DEBUG'                 Set-AzContext -SubscriptionId $sub.Id | Out-Null                 try {                     Write-Log "Probing Get-AzKeyVault -VaultName $VaultName in subscription $($sub.Name)" -Level 'DEBUG'                     $vault = Get-AzKeyVault -VaultName $VaultName -ErrorAction Stop                     $targetSubscription = $sub                     $foundVault = $vault                     Write-Log "Found vault '$VaultName' in subscription '$($sub.Name)'" -Level "SUCCESS"                     break                 } catch {                     # Vault not in this subscription, continue                     Write-Log "Vault not in subscription $($sub.Name) or not accessible: $($_.Exception.Message)" -Level "DEBUG"                 }             }         }          if (-not $targetSubscription) {             Write-Log "Vault '$VaultName' not found in any accessible subscription" -Level "ERROR"             exit 1         }          # Get the vault if not already found         if (-not $foundVault) {             Set-AzContext -SubscriptionId $targetSubscription.Id | Out-Null             try {                 $foundVault = Get-AzKeyVault -VaultName $VaultName             } catch {                 Write-Log "Failed to retrieve vault '$VaultName': $($_.Exception.Message)" -Level "ERROR"                 exit 1             }         }          # Create single-item arrays for processing         $subscriptions = @($targetSubscription)         $keyVaults = @($foundVault)          Write-Log "Single Vault Analysis: $VaultName in subscription $($targetSubscription.Name)" -Level "INFO"     } else {         # Get subscriptions to analyze         $subscriptions = Get-SubscriptionsToAnalyze         if ($subscriptions.Count -eq 0) {             Write-Log "No subscriptions found or accessible. Exiting." -Level "ERROR"             exit 1         }     }      $totalVaultsAnalyzed = 0     $platformAssessments = @()     $vaultsProcessedInTestMode = 0      # Initialize global variables for this run     $global:gapAnalysisResults = @()     $global:securityGaps = @()     $global:quickWins = @()     $global:recommendations = @()      # Load checkpoint if resume requested     $checkpoint = @{}     if ($Resume) {         Write-Log "Resume requested - loading checkpoint if present" -Level "INFO"         $checkpoint = Load-Checkpoint         if (-not $checkpoint) { $checkpoint = @{} }     }      # Analyze each subscription     foreach ($subscription in $subscriptions) {         # If a graceful stop was requested (CTRL-C), break out of subscription processing         if ($global:ScriptStopRequested) {             Write-Log "Script stop requested - aborting further subscription processing" -Level 'WARN'             break         }         # If TestMode limit already reached, stop processing further subscriptions immediately         if ($TestMode -and $vaultsProcessedInTestMode -ge $Limit) {             Write-Log "Test mode limit ($Limit) already reached; stopping subscription processing" -Level 'INFO'             break         }          # Short-circuit scanning for TestMode: first probe for Key Vaults and only         # perform heavier platform assessment work if this subscription contains         # vaults we intend to analyze. This keeps TestMode quick by using the         # minimum number of subscriptions necessary to satisfy -Limit.         Write-Log "Analyzing subscription: $($subscription.Name) ($($subscription.Id))" -Level "INFO"          # If SingleVault and this isn't the target subscription, skip         if ($SingleVault -and $subscription.Id -ne $targetSubscription.Id) { continue }          # Discover vaults first when in TestMode to avoid scanning many subscriptions         if (-not $SingleVault) {             $keyVaults = Get-KeyVaultsInSubscription -SubscriptionId $subscription.Id              if ($keyVaults.Count -eq 0) {                 Write-Log "No Key Vaults found in subscription $($subscription.Name)" -Level "INFO"                 continue             }              # If resuming, filter out vaults already processed per checkpoint             if ($Resume -and $checkpoint.Processed) {                 $keyVaults = $keyVaults | Where-Object { -not $checkpoint.Processed.ContainsKey($_.ResourceId) }                 Write-Log "Resume mode: skipping $([math]::Max(0, ($keyVaults.Count))) already-processed vaults in subscription $($subscription.Name)" -Level "INFO"             }              # Apply test-mode global limit if TestMode is enabled             if ($TestMode) {                 $remainingLimit = $Limit - $vaultsProcessedInTestMode                 if ($remainingLimit -le 0) {                     Write-Log "Test mode limit ($Limit) reached, skipping remaining subscriptions" -Level "INFO"                     break                 }                  if ($keyVaults.Count -gt $remainingLimit) {                     $keyVaults = $keyVaults | Select-Object -First $remainingLimit                     Write-Log "Test mode: Limited to $remainingLimit vaults in this subscription" -Level "INFO"                 }             }         }          # For SingleVault mode, $keyVaults is already set above         if ($TestMode -and -not $SingleVault -and $keyVaults.Count -gt ($Limit - $vaultsProcessedInTestMode)) {             $remainingLimit = $Limit - $vaultsProcessedInTestMode             $keyVaults = $keyVaults | Select-Object -First $remainingLimit             Write-Log "Test mode: Limited to $remainingLimit vaults in this subscription" -Level "INFO"         }          # Now that we know this subscription contains vault(s) we care about,         # perform the (heavier) Azure platform assessment and continue.         $platformAssessment = Get-AzurePlatformAssessment -SubscriptionId $subscription.Id         $platformAssessments += $platformAssessment          # Analyze each vault         if ($UseParallelProcessing -and $env:OS -notlike "*Windows*") {             Write-Log "Parallel processing is only supported on Windows. Falling back to sequential processing." -Level "WARNING"             $UseParallelProcessing = $false         }          if ($UseParallelProcessing) {             Write-Log "Using parallel processing with max $MaxParallelJobs concurrent jobs" -Level "INFO"              # Create vault analysis jobs             $vaultJobs = $keyVaults | ForEach-Object -ThrottleLimit $MaxParallelJobs -Parallel {                 $vault = $_                 $subscriptionId = $using:subscription.Id                 $subscriptionName = $using:subscription.Name                  # Re-establish Azure context in parallel job                 $azContext = $using:azContext                 if ($azContext) {                     try {                         Set-AzContext -Context $azContext | Out-Null                     } catch {                         # Context sharing failed, try alternative authentication                         Write-Log "Parallel job: failed to set Az context in job for subscription ${subscriptionId}: $($_.Exception.Message)" -Level "DEBUG"                         try {                             $null = Connect-AzAccount -Identity -ErrorAction Stop                         } catch {                             Write-Log "Parallel job: Connect-AzAccount -Identity also failed: $($_.Exception.Message)" -Level "DEBUG"                             # If both methods fail, we'll proceed without context and handle errors gracefully                         }                     }                 }                  # Test-mode: attempt an atomic reservation before doing any work in this job                 try {                     if ($using:TestMode) {                         $reserved = $false                         try {                             $reserved = Try-Reserve-TestSlot -Limit $using:Limit -CounterPath $using:testCounterPath                         } catch {                             $reserved = $false                         }                         if (-not $reserved) {                             Write-Log ("Test mode: global limit reached; parallel job skipping vault: $($vault.VaultName)") -Level 'INFO'                             return                         } else {                             Write-Log ("Test mode: reserved slot for vault: $($vault.VaultName)") -Level 'DEBUG'                         }                     }                 } catch { }                  try {                     # Get diagnostics configuration                     $diagnostics = & {                         param($vaultName, $rgName)                         try {                             $diag = Get-AzDiagnosticSetting -ResourceId "\subscriptions\$subscriptionId\resourceGroups\$rgName\providers\Microsoft.KeyVault\vaults\$vaultName" -ErrorAction SilentlyContinue                             return @{                                 HasDiagnostics = ($diag.Count -gt 0)                                 DiagnosticSettings = $diag                                 LogsEnabled = ($diag | Where-Object { $_.Logs.Count -gt 0 }).Count -gt 0                                 MetricsEnabled = ($diag | Where-Object { $_.Metrics.Count -gt 0 }).Count -gt 0                             }                         } catch {                             return @{                                 HasDiagnostics = $false                                 DiagnosticSettings = $null                                 LogsEnabled = $false                                 MetricsEnabled = $false                             }                         }                     } $vault.VaultName $vault.ResourceGroupName                      # Get access control analysis                     $accessControl = & {                         param($vaultName, $rgName, $subId)                         try {                             $vaultObj = Get-AzKeyVault -VaultName $vaultName -ResourceGroupName $rgName                             $rbacEnabled = $vaultObj.EnableRbacAuthorization                             $accessPolicies = $vaultObj.AccessPolicies                             $roleAssignments = Get-AzRoleAssignment -Scope $vaultObj.ResourceId -ErrorAction SilentlyContinue                              return @{                                 RbacEnabled = $rbacEnabled                                 AccessPoliciesCount = $accessPolicies.Count                                 RoleAssignmentsCount = $roleAssignments.Count                                 HasAccessPolicies = ($accessPolicies.Count -gt 0)                                 HasRoleAssignments = ($roleAssignments.Count -gt 0)                             }                         } catch {                             return @{                                 RbacEnabled = $null                                 AccessPoliciesCount = 0                                 RoleAssignmentsCount = 0                                 HasAccessPolicies = $false                                 HasRoleAssignments = $false                             }                         }                     } $vault.VaultName $vault.ResourceGroupName $subscriptionId                      # Get network security analysis                     $networkSecurity = & {                         param($vaultName, $rgName)                         try {                             $vaultObj = Get-AzKeyVault -VaultName $vaultName -ResourceGroupName $rgName                             $networkAcls = $vaultObj.NetworkAcls                             $privateEndpoints = Get-AzPrivateEndpoint | Where-Object {                                 $_.PrivateLinkServiceConnections.PrivateLinkServiceId -like "*$vaultName*"                             }                              return @{                                 PublicNetworkAccess = $vaultObj.PublicNetworkAccess                                 NetworkAclsConfigured = ($null -ne $networkAcls)                                 PrivateEndpointsCount = $privateEndpoints.Count                                 HasPrivateEndpoints = ($privateEndpoints.Count -gt 0)                                 TrustedServicesEnabled = $networkAcls.Bypass -contains "AzureServices"                             }                         } catch {                             return @{                                 PublicNetworkAccess = $null                                 NetworkAclsConfigured = $false                                 PrivateEndpointsCount = 0                                 HasPrivateEndpoints = $false                                 TrustedServicesEnabled = $false                             }                         }                     } $vault.VaultName $vault.ResourceGroupName                      # Calculate compliance score and identify gaps                     $gaps = @()                     $wins = @()                      # Security gap identification logic                     if (!$accessControl.RbacEnabled -and $accessControl.AccessPoliciesCount -eq 0) {                         $gaps += @{                             Category = "Access Control"                             Severity = "Critical"                             Issue = "No access control configured"                             Impact = "Vault is inaccessible"                             Recommendation = "Enable RBAC or configure access policies"                         }                     }                      if (!$diagnostics.HasDiagnostics) {                         $gaps += @{                             Category = "Monitoring"                             Severity = "High"                             Issue = "No diagnostic settings configured"                             Impact = "No audit logging or monitoring"                             Recommendation = "Enable diagnostic settings to Log Analytics or Event Hub"                         }                     }                      if ($networkSecurity.PublicNetworkAccess -eq "Enabled" -and !$networkSecurity.HasPrivateEndpoints) {                         $gaps += @{                             Category = "Network Security"                             Severity = "Medium"                             Issue = "Public network access enabled without private endpoints"                             Impact = "Potential exposure to public internet"                             Recommendation = "Configure private endpoints or restrict network access"                         }                     }                      # Quick wins logic                     if ($accessControl.AccessPoliciesCount -gt 0 -and !$accessControl.RbacEnabled) {                         $wins += @{                             Category = "Access Control"                             Title = "Migrate to RBAC"                             Description = "Replace access policies with Azure RBAC for better security and management"                             Effort = "Medium"                             Impact = "High"                         }                     }                      if (!$diagnostics.HasDiagnostics) {                         $wins += @{                             Category = "Monitoring"                             Title = "Enable Diagnostic Logging"                             Description = "Configure diagnostic settings to capture audit logs and metrics"                             Effort = "Low"                             Impact = "High"                         }                     }                      # Calculate compliance score                     $score = 100                     foreach ($gap in $gaps) {                         switch ($gap.Severity) {                             "Critical" { $score -= 25 }                             "High" { $score -= 15 }                             "Medium" { $score -= 10 }                             "Low" { $score -= 5 }                         }                     }                      # Bonus points                     if ($diagnostics.HasDiagnostics) { $score += 10 }                     if ($accessControl.RbacEnabled) { $score += 10 }                     if ($networkSecurity.HasPrivateEndpoints) { $score += 10 }                      $complianceScore = [math]::Max(0, [math]::Min(100, $score))                     $riskLevel = switch ($complianceScore) {                         { $_ -ge 90 } { "Low" }                         { $_ -ge 70 } { "Medium" }                         { $_ -ge 50 } { "High" }                         default { "Critical" }                     }                      return @{                         SubscriptionId = $subscriptionId                         SubscriptionName = $subscriptionName                         VaultName = $vault.VaultName                         ResourceGroupName = $vault.ResourceGroupName                         Location = $vault.Location                         Diagnostics = $diagnostics                         AccessControl = $accessControl                         NetworkSecurity = $networkSecurity                         SecurityGaps = $gaps                         QuickWins = $wins                         ComplianceScore = $complianceScore                         RiskLevel = $riskLevel                         Vault = $vault                         WorkerId = "$($env:COMPUTERNAME)_$PID"                     }                 } catch {                     return @{                         SubscriptionId = $subscriptionId                         SubscriptionName = $subscriptionName                         VaultName = $vault.VaultName                         ResourceGroupName = $vault.ResourceGroupName                         Location = $vault.Location                         Diagnostics = @{ HasDiagnostics = $false }                         AccessControl = @{ RbacEnabled = $false; AccessPoliciesCount = 0; RoleAssignmentsCount = 0 }                         NetworkSecurity = @{ HasPrivateEndpoints = $false }                         SecurityGaps = @(@{ Category = "Error"; Severity = "High"; Issue = "Analysis failed: $($_.Exception.Message)" })                         QuickWins = @()                         ComplianceScore = 0                         RiskLevel = "Critical"                         Vault = $vault                         WorkerId = "$($env:COMPUTERNAME)_$PID"                     }                 }             }              # Collect results from parallel jobs             foreach ($result in $vaultJobs) {                 if ($global:ScriptStopRequested) {                     Write-Log "Script stop requested - halting collection of parallel results" -Level 'WARN'                     break                 }                 $global:gapAnalysisResults += $result                 $totalVaultsAnalyzed++                 $vaultsProcessedInTestMode++                  # persist per-vault JSON\marker if available                 try {                     if ($result.Vault -and $result.Vault.ResourceId) {                         Write-Log "Finished analysis of $($result.VaultName) - persisting marker and checkpoint" -Level 'INFO'                         $jsonPath = $null                         if ($result.JsonFilePath) { $jsonPath = $result.JsonFilePath }                         Mark-Vault-Processed -VaultResourceId $result.Vault.ResourceId -JsonFilePath $jsonPath                         # Immediately persist checkpoint for recoverability                         try { Save-Checkpoint-Atomic -State $global:checkpoint } catch { Write-Log "Checkpoint save failed: $($_.Exception.Message)" -Level 'WARN' }                         # Append to incremental CSV. When running in parallel, write to a per-worker temp                         try {                             $row = Build-MasterCsvRecord -Analysis $result                             if ($UseParallelProcessing) {                                 $wId = $null                                 if ($result.PSObject.Properties.Name -contains 'WorkerId') { $wId = $result.WorkerId }                                 Append-IncrementalCsvRow -Row $row -WorkerId $wId                             } else {                                 Append-IncrementalCsvRow -Row $row                             }                         } catch {                             # Non-fatal: continue on append errors                         }                     }                 } catch { }                  Write-Log "Completed parallel analysis of $($result.VaultName) - Score: $($result.ComplianceScore)%, Risk: $($result.RiskLevel)" -Level "INFO"                  # Check if we've reached the overall limit                 if ($TestMode -and $vaultsProcessedInTestMode -ge $Limit) {                     Write-Log "Test mode limit ($Limit) reached, stopping analysis" -Level "INFO"                     break                 }                  # Simulate an interrupt for testing if requested                 if ($SimulateInterruptAfter -and $SimulateInterruptAfter -gt 0 -and $vaultsProcessedInTestMode -ge $SimulateInterruptAfter) {                     Write-Log "SimulateInterruptAfter threshold reached ($SimulateInterruptAfter) - saving checkpoint and setting stop flag" -Level "WARN"                     $global:ScriptStopRequested = $true                     try {                         try {                             Save-Checkpoint-Atomic -State $global:checkpoint                             Write-Log "Checkpoint saved to: $(Get-CheckpointPath)" -Level "INFO"                         } catch {                             Write-Log "Save-Checkpoint-Atomic failed: $($_.Exception.Message)" -Level 'ERROR'                         }                     } catch {                         Write-Log "Failed to save checkpoint during simulated interrupt: $($_.Exception.Message)" -Level "ERROR"                     }                     break                 }                  # Simulation: optionally trigger an interrupt after N processed vaults                 if ($SimulateInterruptAfter -gt 0 -and $vaultsProcessedInTestMode -ge $SimulateInterruptAfter) {                     Write-Log "SimulateInterruptAfter reached ($SimulateInterruptAfter) - simulating CTRL-C and saving checkpoint" -Level 'WARN'                     $global:ScriptStopRequested = $true                     try { Save-Checkpoint-Atomic -State $global:checkpoint } catch { }                     break                 }             }         } else {             # Sequential processing (original logic)             foreach ($vault in $keyVaults) {                 if ($global:ScriptStopRequested) {                     Write-Log "Script stop requested - aborting sequential vault processing" -Level 'WARN'                     break                 }                 # mark current in-progress vault so CTRL-C handler can persist a partial checkpoint if needed                 $global:currentVaultInProgress = $vault.ResourceId                  # Test-mode: attempt an atomic reservation before processing this vault (only for parallel processing)                 if ($TestMode -and $UseParallelProcessing) {                     try {                         $reserved = Try-Reserve-TestSlot -Limit $Limit -CounterPath $testCounterPath                     } catch {                         $reserved = $false                     }                     if (-not $reserved) {                         Write-Log "Test mode: global limit reached; skipping remaining vaults" -Level 'INFO'                         break                     } else {                         Write-Log ("Test mode: reserved slot for vault: $($vault.VaultName)") -Level 'DEBUG'                     }                 }                 $analysis = Analyze-KeyVault -Vault $vault -SubscriptionId $subscription.Id -SubscriptionName $subscription.Name                 $global:gapAnalysisResults += $analysis                 $totalVaultsAnalyzed++                 $vaultsProcessedInTestMode++                  # persist per-vault JSON\marker                 try {                     if ($analysis.Vault -and $analysis.Vault.ResourceId) {                         Write-Log "Finished analysis of $($analysis.Vault.VaultName) - persisting marker and checkpoint" -Level 'INFO'                         $jsonPath = $null                         if ($analysis.JsonFilePath) { $jsonPath = $analysis.JsonFilePath }                         Mark-Vault-Processed -VaultResourceId $analysis.Vault.ResourceId -JsonFilePath $jsonPath                         # clear in-progress marker now that vault completed successfully                         $global:currentVaultInProgress = $null                         # Immediately persist checkpoint for recoverability                         try { Save-Checkpoint-Atomic -State $global:checkpoint } catch { Write-Log "Checkpoint save failed: $($_.Exception.Message)" -Level 'WARN' }                         # Append to incremental CSV when sequential                         if (-not $UseParallelProcessing) {                             try { $row = Build-MasterCsvRecord -Analysis $analysis; Append-IncrementalCsvRow -Row $row } catch { }                         }                     }                 } catch { }                  Write-Log "Completed analysis of $($vault.VaultName) - Score: $($analysis.ComplianceScore)%, Risk: $($analysis.RiskLevel)" -Level "INFO"                  # Check if we've reached the overall limit                 if ($TestMode -and $vaultsProcessedInTestMode -ge $Limit) {                     Write-Log "Test mode limit ($Limit) reached, stopping analysis" -Level "INFO"                     break                 }                      # Simulate an interrupt for testing if requested                     if ($SimulateInterruptAfter -and $SimulateInterruptAfter -gt 0 -and $vaultsProcessedInTestMode -ge $SimulateInterruptAfter) {                         Write-Log "SimulateInterruptAfter threshold reached ($SimulateInterruptAfter) - saving checkpoint and setting stop flag" -Level "WARN"                         $global:ScriptStopRequested = $true                         try {                             try {                                 Save-Checkpoint-Atomic -State $global:checkpoint                                 Write-Log "Checkpoint saved to: $(Get-CheckpointPath)" -Level "INFO"                             } catch {                                 Write-Log "Save-Checkpoint-Atomic failed: $($_.Exception.Message)" -Level 'ERROR'                             }                         } catch {                             Write-Log "Failed to save checkpoint during simulated interrupt: $($_.Exception.Message)" -Level "ERROR"                         }                         break                     }                  # Simulation: optionally trigger an interrupt after N processed vaults                 if ($SimulateInterruptAfter -gt 0 -and $vaultsProcessedInTestMode -ge $SimulateInterruptAfter) {                     Write-Log "SimulateInterruptAfter reached ($SimulateInterruptAfter) - simulating CTRL-C and saving checkpoint" -Level 'WARN'                     $global:ScriptStopRequested = $true                     try { Save-Checkpoint-Atomic -State $global:checkpoint } catch { }                     break                 }             }         }          # Break out of subscription loop if overall limit reached         if ($TestMode -and $vaultsProcessedInTestMode -ge $Limit) {             break         }     }      # Export CSV results     Write-Log "Exporting CSV results..." -Level "INFO"     # Merge any per-worker incremental temp files into the master incremental CSV (parallel-safe)     try { Merge-IncrementalTempFiles } catch { }     Write-Log "Analysis results count: $($global:gapAnalysisResults.Count)" -Level "INFO"      if ($global:gapAnalysisResults -and $global:gapAnalysisResults.Count -gt 0) {         # --- Normalization: QuickWins dedupe and deterministic counts ---         # Ensure QuickWins titles are deduplicated (case-insensitive) per-vault         # so both CSV and HTML compute totals from the same canonical set.         try {             foreach ($a in $global:gapAnalysisResults) {                 if ($null -ne $a.QuickWins -and ($a.QuickWins -is [System.Collections.IEnumerable])) {                     # Group by lowercased Title to dedupe recommendations that differ only by case                     $deduped = ($a.QuickWins | Where-Object { $_.Title } | Group-Object -Property { ($_.Title -as [string]).ToLowerInvariant() } | ForEach-Object { $_.Group[0] })                     $a.QuickWins = @()                     if ($deduped) { $a.QuickWins = $deduped }                     # Ensure a numeric QuickWinsCount is present and deterministic                     try { $a.QuickWinsCount = ($a.QuickWins | Where-Object { $_.Title } | Measure-Object).Count } catch { $a.QuickWinsCount = 0 }                 } else {                     $a.QuickWins = @()                     $a.QuickWinsCount = 0                 }             }              # Compute global unique quick-win titles across all vaults (canonicalized)             $allTitles = @()             foreach ($v in $global:gapAnalysisResults) {                 foreach ($w in $v.QuickWins) { if ($w.Title) { $allTitles += ($w.Title -as [string]) } }             }             $uniqueWinTitles = ($allTitles | ForEach-Object { $_.Trim() } | Where-Object { $_ -and $_ -ne '' } | ForEach-Object { $_.ToLowerInvariant() } | Sort-Object -Unique)             $global:TotalQuickWinsUnique = ($uniqueWinTitles).Count             Write-Log "Canonical QuickWins unique titles: $($global:TotalQuickWinsUnique)" -Level "INFO"         } catch {             Write-Log "QuickWins normalization failed: $($_.Exception.Message)" -Level "WARN"         }          # Enrich results with additional Az CLI\Pwsh data (best-effort)         Write-Log "Starting enrichment of $($global:gapAnalysisResults.Count) results with Collect-ExtraAzData" -Level 'INFO'         $enrichStart = Get-Date         $enrichedResults = @()         foreach ($gr in $global:gapAnalysisResults) {             try {                 Write-Log "Enriching vault: $($gr.VaultName) ($($gr.Vault.ResourceId))" -Level 'INFO'                 $er = Collect-ExtraAzData -Analysis $gr                 $enrichedResults += $er                 Write-Log "Enriched vault: $($gr.VaultName) - done" -Level 'INFO'             } catch {                 Write-Log "Collect-ExtraAzData threw for $($gr.VaultName): $($_.Exception.Message)" -Level 'ERROR'                 $enrichedResults += $gr             }         }         $enrichDur = (Get-Date) - $enrichStart         Write-Log "Enrichment completed for $($enrichedResults.Count) vault(s) in $([math]::Round($enrichDur.TotalSeconds,2))s" -Level 'INFO'          # Progress marker file to help diagnose hangs\stalls (appends latest step)         $progressFile = Join-Path -Path $env:TEMP -ChildPath 'akv_gap_progress.txt'         function Write-ProgressMarker([string]$m) {             try {                 $t = (Get-Date).ToString('o')                 "$t`t$m" | Out-File -FilePath $progressFile -Encoding UTF8 -Append -Force             } catch { }         }          # Flatten the enriched results for CSV export using the master record builder         Write-Log "Starting Build-MasterCsvRecord for $($enrichedResults.Count) enriched results" -Level 'INFO'         Write-ProgressMarker ("Starting Build-MasterCsvRecord for {0} enriched results" -f $enrichedResults.Count)         $buildStart = Get-Date         $flattenedResults = @()         foreach ($er in $enrichedResults) {             try {                 $id = ''                 try { $id = $er.VaultName -as [string] } catch { $id = ($er.Vault.ResourceId -as [string]) }                 Write-Log "Building CSV record for: $id" -Level 'INFO'                 $row = Build-MasterCsvRecord -Analysis $er                 if ($row -ne $null) { $flattenedResults += $row; Write-Log "Built CSV record for: $id" -Level 'INFO'; Write-ProgressMarker ("Built CSV record for: {0}" -f $id) } else { Write-Log "Build-MasterCsvRecord returned null for: $id" -Level 'WARN'; Write-ProgressMarker ("Build-MasterCsvRecord returned null for: {0}" -f $id) }             } catch {                 Write-Log ("Error building CSV record for {0}: {1}" -f $id, ($_.Exception.Message -as [string])) -Level 'ERROR'             }         }         $buildDur = (Get-Date) - $buildStart         Write-Log "Build-MasterCsvRecord completed for $($flattenedResults.Count) records in $([math]::Round($buildDur.TotalSeconds,2))s" -Level 'INFO'          # Final coercion pass: build a safe, new PSCustomObject per row so we don't try to set properties         # on values that may be immutable or missing properties. This also makes exported CSVs stable.         try {             # Allow test-time override of the final coercion timeout and heartbeat via env vars or global vars.             $finalCoercionTimeout = 60             if ($env:FINAL_COERCION_TIMEOUT) {                 try { $finalCoercionTimeout = [int]$env:FINAL_COERCION_TIMEOUT } catch { }             } elseif ($global:FinalCoercionTimeoutSeconds) {                 try { $finalCoercionTimeout = [int]$global:FinalCoercionTimeoutSeconds } catch { }             }             $finalCoercionHeartbeat = 5             if ($env:FINAL_COERCION_HEARTBEAT) {                 try { $finalCoercionHeartbeat = [int]$env:FINAL_COERCION_HEARTBEAT } catch { }             } elseif ($global:FinalCoercionHeartbeatSeconds) {                 try { $finalCoercionHeartbeat = [int]$global:FinalCoercionHeartbeatSeconds } catch { }             }              Write-Log "Final coercion timeout set to ${finalCoercionTimeout}s (heartbeat ${finalCoercionHeartbeat}s)" -Level 'DEBUG'              # To avoid Start-Job serialization issues with complex Az\PSObject types,             # write the flattened results to a temporary JSON file and pass the file             # path to the background job. The job will read and parse the JSON which             # avoids attempting to serialize CLR types across runspaces.             $finalCoercionTemp = Join-Path -Path $env:TEMP -ChildPath ("akv_final_coercion_{0}.json" -f ([guid]::NewGuid().ToString()))             # Normalize flattenedResults: drop obvious primitives or empty\zero-property items to avoid coercion confusion             try {                 $preCount = 0; if ($flattenedResults) { $preCount = $flattenedResults.Count }             } catch { $preCount = 0 }             try {                 $flattenedResults = @($flattenedResults | Where-Object { $_ -and ( ($_ -is [PSObject]) -or ($_ -is [hashtable]) ) -and ($_.PSObject.Properties.Count -gt 0) })             } catch { }             try { $filteredCount = $flattenedResults.Count } catch { $filteredCount = 0 }             Write-Log "Final coercion: filtered flattenedResults $preCount -> $filteredCount (dropped non-object\empty rows)" -Level 'DEBUG'             try {                 $flattenedResults | ConvertTo-Json -Depth 10 -Compress | Out-File -FilePath $finalCoercionTemp -Encoding UTF8 -Force                 Write-ProgressMarker ("WROTE_FINAL_COERCION_TEMP {0} count={1}" -f $finalCoercionTemp, $filteredCount)             } catch {                 # Fallback: try a lower depth if conversion fails                 try { $flattenedResults | ConvertTo-Json -Depth 6 | Out-File -FilePath $finalCoercionTemp -Encoding UTF8 -Force; Write-ProgressMarker ("WROTE_FINAL_COERCION_TEMP (fallback depth6) {0} count={1}" -f $finalCoercionTemp, $filteredCount) } catch { Write-ProgressMarker ("FAILED_WRITE_FINAL_COERCION_TEMP {0}" -f $finalCoercionTemp) }             }              $finalCoercionScript = {                 param($rowsOrPath)                 # If the caller passed a file path, read JSON from disk to obtain rows                 $rows = $null                 try {                     if ($rowsOrPath -is [string] -and (Test-Path $rowsOrPath)) {                         $txt = Get-Content -Path $rowsOrPath -Raw -ErrorAction Stop                         try { $rows = $txt | ConvertFrom-Json -ErrorAction Stop } catch { $rows = @() }                     } else {                         $rows = $rowsOrPath                     }                 } catch {                     $rows = @()                 }                 # Testing hook: if FORCE_FINAL_COERCION env var is set, sleep inside                 # the timed scriptblock long enough to guarantee the heartbeat                 # wrapper will time out and trigger the diagnostic writer.                 try {                     if ($env:FORCE_FINAL_COERCION -and $env:FORCE_FINAL_COERCION -ne '') {                         $baseTimeout = 60                         if ($env:FINAL_COERCION_TIMEOUT) {                             try { $baseTimeout = [int]$env:FINAL_COERCION_TIMEOUT } catch { }                         }                         $sleepSec = $baseTimeout + 10                         if ($env:FORCE_FINAL_COERCION_SLEEP) {                             try { $sleepSec = [int]$env:FORCE_FINAL_COERCION_SLEEP } catch { }                         }                         Write-Output "FORCE_FINAL_COERCION detected: sleeping ${sleepSec}s to trigger final-coercion timeout"                         Start-Sleep -Seconds $sleepSec                     }                 } catch {                     # swallow test-hook failures so they don't affect main logic                 }                 $localFinal = @()                 $diagMsgs = @()                 # Normalize incoming rows: ensure we have a flat array of objects to iterate                 $rowsToProcess = @()                 try {                     if ($null -eq $rows) {                         $rowsToProcess = @()                     } elseif ($rows -is [System.Collections.IEnumerable] -and -not ($rows -is [string])) {                         foreach ($r in $rows) { $rowsToProcess += $r }                     } else {                         $rowsToProcess += $rows                     }                 } catch {                     # fallback: wrap as single element                     $rowsToProcess = @($rows)                 }                 # Add optional bounds and progress logging for in-process runs                 $rowIndex = 0                 $coercionStart = Get-Date                 $maxRows = $null                 $maxSeconds = $null                 if ($env:FINAL_COERCION_MAX_ROWS) { try { $maxRows = [int]$env:FINAL_COERCION_MAX_ROWS } catch { $maxRows = $null } }                 if ($env:FINAL_COERCION_MAX_SECONDS) { try { $maxSeconds = [int]$env:FINAL_COERCION_MAX_SECONDS } catch { $maxSeconds = $null } }                 # In-process guard: maximum seconds to allow synchronous coercion (0 = unlimited)                 $inprocessMaxSec = 0                 if ($env:FINAL_COERCION_INPROCESS_MAX_SECONDS) { try { $inprocessMaxSec = [int]$env:FINAL_COERCION_INPROCESS_MAX_SECONDS } catch { $inprocessMaxSec = 0 } }                 # Allow skipping per-vault JSON writes when running in-process for faster runs                 $disablePerVaultJson = $false                 if ($env:DISABLE_PER_VAULT_JSON -and $env:DISABLE_PER_VAULT_JSON -ne '') { $disablePerVaultJson = $true }                 if ($rowsToProcess.Count -eq 0) { Write-Log "[COERCION] No rows to process in final coercion" -Level 'DEBUG' }                 foreach ($orig in $rowsToProcess) {                     $rowIndex++                     if ($rowIndex % 10 -eq 0) {                         $elapsed = (Get-Date) - $coercionStart                         Write-Log "[COERCION] Processing row $rowIndex of $($rowsToProcess.Count) (elapsed: $([math]::Round($elapsed.TotalSeconds,1))s)" -Level 'DEBUG'                     }                     # Respect optional bounds to avoid unbounded synchronous runs                     if ($maxRows -and $rowIndex -gt $maxRows) {                         $diagMsgs += ("Stopped coercion after {0} rows due to FINAL_COERCION_MAX_ROWS" -f $maxRows)                         break                     }                     if ($maxSeconds) {                         $elapsed = (Get-Date) - $coercionStart                         if ($elapsed.TotalSeconds -gt $maxSeconds) {                             $diagMsgs += ("Stopped coercion after {0}s due to FINAL_COERCION_MAX_SECONDS" -f $maxSeconds)                             break                         }                     }                      # Per-row diagnostics: type and prop count                     $rowStart = Get-Date                     try { $rowType = if ($null -eq $orig) { 'Null' } else { $orig.GetType().FullName } } catch { $rowType = 'Unknown' }                     try { $propCount = if ($orig -and $orig.PSObject -and $orig.PSObject.Properties) { $orig.PSObject.Properties.Count } else { 0 } } catch { $propCount = 0 }                     Write-Log "[COERCION] Row #$rowIndex type=$rowType propCount=$propCount VaultName='$($orig.VaultName -as [string])'" -Level 'DEBUG'                      # If the incoming element looks like a primitive (no properties and is value type\string), coerce into hashtable                     if ($propCount -eq 0 -and ($orig -is [string] -or $orig -is [System.ValueType] -or $rowType -eq 'System.Boolean')) {                         try {                             $co = [ordered]@{}                             $co['Value'] = ($orig -as [string]) ?? ''                             $orig = [PSCustomObject]$co                             Write-Log "[COERCION] Coerced non-object row #$rowIndex to PSCustomObject" -Level 'DEBUG'                         } catch {                             $errMsg = $_.Exception.Message                             Write-Log ("[COERCION] Failed to coerce non-object row #{0}: {1}" -f $rowIndex, $errMsg) -Level 'WARN'                         }                     }                      # Start with an ordered hashtable copy of existing properties when possible                     $props = [ordered]@{}                     try {                         foreach ($p in $orig.PSObject.Properties) {                             $val = $p.Value                             # Flatten arrays to string for CSV                             if ($val -is [System.Collections.IEnumerable] -and -not ($val -is [string])) {                                 try { $val = ($val | ForEach-Object { $_.ToString() }) -join '; ' } catch { $val = $val.ToString() }                             }                             $props[$p.Name] = $val                         }                         Write-Log "[COERCION] Processed props for $($orig.VaultName -as [string]): $($props | Out-String)" -Level 'DEBUG'                     } catch {                         $props['Value'] = ($orig -as [string]) ?? ''                         Write-Log "[COERCION] Failed to process props for $($orig): $($_.Exception.Message)" -Level 'ERROR'                     }                      # Helper to safely read from $props (local)                     function Get-PropValueLocal([hashtable]$h, [string]$name) {                         if ($h.ContainsKey($name)) { return $h[$name] } else { return $null }                     }                      try {                         # Coerce RoleAssignmentsResolved to a predictable string                         $rawRole = Get-PropValueLocal $props 'RoleAssignmentsResolved'                         if ($null -eq $rawRole) {                             $props['RoleAssignmentsResolved'] = ''                         } elseif ($rawRole -is [string]) {                             $props['RoleAssignmentsResolved'] = $rawRole                         } elseif ($rawRole -is [System.Collections.IEnumerable]) {                             $parts = @()                             foreach ($elem in $rawRole) {                                 if ($null -eq $elem) { continue }                                 if ($elem -is [PSObject] -or $elem -is [hashtable]) {                                     try { $parts += (ConvertTo-Json $elem -Depth 2 -Compress) } catch { $parts += $elem.ToString() }                                 } else { $parts += $elem.ToString() }                             }                             $props['RoleAssignmentsResolved'] = ($parts | Where-Object { $_ -and $_ -ne '' }) -join '; '                         } else {                             $props['RoleAssignmentsResolved'] = ($rawRole -as [string]) ?? ''                         }                     } catch {                         $props['RoleAssignmentsResolved'] = ''                     }                      # Coerce VaultScore to int scalar                     try {                         $vs = Get-PropValueLocal $props 'VaultScore'                         $cs = Get-PropValueLocal $props 'ComplianceScore'                         $props['VaultScore'] = ($vs -as [int]) ?? ($cs -as [int]) ?? 0                     } catch {                         $props['VaultScore'] = (Get-PropValueLocal $props 'ComplianceScore' -as [int]) ?? 0                     }                      # Ensure JsonFilePath is string                     $props['JsonFilePath'] = (Get-PropValueLocal $props 'JsonFilePath' -as [string]) ?? ''                      # If a per-vault JSON path exists, write a compact vault JSON using the coerced scalars                     try {                         $jsonPath = $props['JsonFilePath']                         if (-not $disablePerVaultJson -and $jsonPath -and $jsonPath -ne '') {                             $vaultExport = [ordered]@{                                 Timestamp = (Get-Date).ToString('o')                                 SubscriptionId = (Get-PropValueLocal $props 'SubscriptionId' -as [string]) ?? ''                                 SubscriptionName = (Get-PropValueLocal $props 'SubscriptionName' -as [string]) ?? ''                                 VaultName = (Get-PropValueLocal $props 'VaultName' -as [string]) ?? ''                                 VaultResourceId = (Get-PropValueLocal $props 'VaultResourceId' -as [string]) ?? ''                                 Location = (Get-PropValueLocal $props 'Location' -as [string]) ?? ''                                 ComplianceScore = (Get-PropValueLocal $props 'ComplianceScore' -as [int]) ?? 0                                 VaultScore = ($props['VaultScore'] -as [int]) ?? 0                                 RoleAssignmentsResolved = ($props['RoleAssignmentsResolved'] -as [string]) ?? ''                                 ManagedIdentityResolved = (Get-PropValueLocal $props 'ManagedIdentityResolved' -as [string]) ?? ''                                 DiagnosticDestinationNames = (Get-PropValueLocal $props 'DiagnosticDestinationNames' -as [string]) ?? ''                                 SkuName = (Get-PropValueLocal $props 'SkuName' -as [string]) ?? ''                                 SecretRotationMostRecent = (Get-PropValueLocal $props 'SecretRotationMostRecent' -as [string]) ?? ''                                 KeyRotationMostRecent = (Get-PropValueLocal $props 'KeyRotationMostRecent' -as [string]) ?? ''                                 JsonFilePath = $jsonPath                             }                             try {                                 Write-ProgressMarker ("ATTEMPT_PER_VAULT_JSON {0}" -f $jsonPath)                                 # Use a simple Out-File for per-vault JSON to avoid atomic helpers that may block on special filesystems                                 $vaultExport | ConvertTo-Json -Depth 4 | Out-File -FilePath $jsonPath -Encoding UTF8 -Force                                 Write-ProgressMarker ("WROTE_PER_VAULT_JSON {0}" -f $jsonPath)                             } catch {                                 Write-Log "[COERCION] Failed to write per-vault JSON for $($props['VaultName'] -as [string]): $($_.Exception.Message)" -Level 'DEBUG'                                 Write-ProgressMarker ("FAILED_PER_VAULT_JSON {0} err={1}" -f $jsonPath, ($_.Exception.Message -replace '\r|\n',' '))                             }                         }                     } catch {                         # ignore failures to write per-vault JSON - CSV should still be the authoritative output                     }                      # Record a small diagnostic message for the caller                     try {                         $vn = (Get-PropValueLocal $props 'VaultName' -as [string]) ?? ''                         $diagMsgs += ("Processed vault: {0}" -f $vn)                     } catch { }                      try {                         if ($props -is [hashtable]) {                             $localFinal += [PSCustomObject]$props                         } else {                             # Ensure we always have some representation                             try { $localFinal += [PSCustomObject]@{ Value = ($orig -as [string]) ?? '' } } catch { }                             Write-Log "[COERCION] Skipped non-hashtable props for $($orig.VaultName -as [string])" -Level 'ERROR'                         }                     } catch {                         Write-Log "[COERCION] Failed to cast props to PSCustomObject for $($orig.VaultName -as [string]): $($_.Exception.Message)" -Level 'ERROR'                     }                      # Check total elapsed time for in-process guard                     if ($inprocessMaxSec -gt 0) {                         $elapsed = (Get-Date) - $coercionStart                         if ($elapsed.TotalSeconds -ge $inprocessMaxSec) {                             Write-Log "[COERCION] Aborting in-process final coercion after $([math]::Round($elapsed.TotalSeconds,1))s (max=${inprocessMaxSec}s)" -Level 'WARN'                             $diagMsgs += ("Aborted in-process after processing $rowIndex rows due to FINAL_COERCION_INPROCESS_MAX_SECONDS")                             break                         }                     }                     # Per-row duration debug (only if slow)                     $rowDur = (Get-Date) - $rowStart                     if ($rowDur.TotalSeconds -gt 1) {                         Write-Log "[COERCION] Slow row #$rowIndex processed in $([math]::Round($rowDur.TotalSeconds,2))s" -Level 'DEBUG'                     }                 }                  return @{ Results = $localFinal; Messages = $diagMsgs }             }              # Decide whether to run final coercion in a timed background job or inline.             # Default: use background job (Invoke-WithHeartbeat). But for small\test runs             # prefer in-process to avoid Start-Job serialization issues and command-line limits.             $inprocessLimit = 3             if ($env:FINAL_COERCION_INPROCESS_LIMIT) { try { $inprocessLimit = [int]$env:FINAL_COERCION_INPROCESS_LIMIT } catch { $inprocessLimit = 3 } }              $shouldForceInProcess = $false             if ($env:FORCE_FINAL_COERCION_MODE -and ($env:FORCE_FINAL_COERCION_MODE -ieq 'inprocess' -or $env:FORCE_FINAL_COERCION_MODE -ieq 'local')) { $shouldForceInProcess = $true }             if ($global:ForceInProcessFinalCoercion) { $shouldForceInProcess = $true }             # If running TestMode or processing only a small number of vaults (Limit), prefer in-process             try {                 if ($TestMode) { $shouldForceInProcess = $true }                 if (($Limit -as [int]) -ne $null) { if ($Limit -le $inprocessLimit) { $shouldForceInProcess = $true } }             } catch { }              if ($shouldForceInProcess) {                 Write-Log "Running final coercion synchronously in-process (shouldForceInProcess=$shouldForceInProcess)" -Level 'WARN'                 # When running coercion in-process, avoid per-vault JSON writes which may                 # hang on slow filesystems (OneDrive, network mounts) or cause long IO.                 Write-Log "Disabling per-vault JSON writes for in-process final coercion" -Level 'DEBUG'                 $env:DISABLE_PER_VAULT_JSON = '1'                 try {                     $invokeResult = & $finalCoercionScript $finalCoercionTemp                 } catch {                     throw                 } finally {                     # restore env var if previously unset                     try { Remove-Item Env:DISABLE_PER_VAULT_JSON -ErrorAction SilentlyContinue } catch { }                 }             } else {                 $invokeResult = Invoke-WithHeartbeat -ScriptBlock $finalCoercionScript -Args @($finalCoercionTemp) -TimeoutSeconds $finalCoercionTimeout -HeartbeatSeconds $finalCoercionHeartbeat -Description 'Final coercion & per-vault JSON writes'             }             # Cleanup temp file (best-effort)             try { if (Test-Path $finalCoercionTemp) { Remove-Item -Path $finalCoercionTemp -Force -ErrorAction SilentlyContinue } } catch {}              # Unpack invoke result and log diagnostic messages             $finalResults = @()             if ($invokeResult -and $invokeResult.Results) { $finalResults = $invokeResult.Results }             try {                 if ($invokeResult -and $invokeResult.Messages) {                     foreach ($m in $invokeResult.Messages) { Write-Log $m -Level 'DEBUG' }                 }             } catch { }         } catch {             Write-Log "Final coercion step timed out or errored: $($_.Exception.Message)" -Level 'ERROR'             # If job-based invocation failed due to Start-Job serialization of complex objects,             # attempt an in-process fallback to perform the same coercion logic synchronously.             if ($_.Exception.Message -and ($_.Exception.Message -match 'Cannot convert the "System.Object\[\]" value')) {                 Write-Log "Detected Start-Job serialization error; attempting in-process final coercion fallback" -Level 'WARN'                 try {                     $localFinalFb = @()                     $diagMsgsFb = @()                     foreach ($orig in $flattenedResults) {                         try {                             $propsFb = [ordered]@{}                             foreach ($p in $orig.PSObject.Properties) {                                 $val = $p.Value                                 if ($val -is [System.Collections.IEnumerable] -and -not ($val -is [string])) {                                     try { $val = ($val | ForEach-Object { $_.ToString() }) -join '; ' } catch { $val = $val.ToString() }                                 }                                 $propsFb[$p.Name] = $val                             }                         } catch {                             $propsFb['Value'] = ($orig -as [string]) ?? ''                         }                          # Coerce RoleAssignmentsResolved                         try {                             $rawRole = $propsFb['RoleAssignmentsResolved']                             if ($null -eq $rawRole) { $propsFb['RoleAssignmentsResolved'] = '' }                             elseif ($rawRole -is [string]) { $propsFb['RoleAssignmentsResolved'] = $rawRole }                             elseif ($rawRole -is [System.Collections.IEnumerable]) {                                 $parts = @()                                 foreach ($elem in $rawRole) {                                     if ($null -eq $elem) { continue }                                     if ($elem -is [PSObject] -or $elem -is [hashtable]) {                                         try { $parts += (ConvertTo-Json $elem -Depth 2 -Compress) } catch { $parts += $elem.ToString() }                                     } else { $parts += $elem.ToString() }                                 }                                 $propsFb['RoleAssignmentsResolved'] = ($parts | Where-Object { $_ -and $_ -ne '' }) -join '; '                             } else { $propsFb['RoleAssignmentsResolved'] = ($rawRole -as [string]) ?? '' }                         } catch { $propsFb['RoleAssignmentsResolved'] = '' }                          # VaultScore                         try {                             $vs = $propsFb['VaultScore']; $cs = $propsFb['ComplianceScore']                             $propsFb['VaultScore'] = ($vs -as [int]) ?? ($cs -as [int]) ?? 0                         } catch { $propsFb['VaultScore'] = ($propsFb['ComplianceScore'] -as [int]) ?? 0 }                          # JsonFilePath                         $propsFb['JsonFilePath'] = ($propsFb['JsonFilePath'] -as [string]) ?? ''                          # Write per-vault JSON if requested                         try {                             $jsonPathFb = $propsFb['JsonFilePath']                             if ($jsonPathFb -and $jsonPathFb -ne '') {                                 $vaultExportFb = [ordered]@{                                     Timestamp = (Get-Date).ToString('o')                                     SubscriptionId = ($propsFb['SubscriptionId'] -as [string]) ?? ''                                     SubscriptionName = ($propsFb['SubscriptionName'] -as [string]) ?? ''                                     VaultName = ($propsFb['VaultName'] -as [string]) ?? ''                                     VaultResourceId = ($propsFb['VaultResourceId'] -as [string]) ?? ''                                     Location = ($propsFb['Location'] -as [string]) ?? ''                                     ComplianceScore = ($propsFb['ComplianceScore'] -as [int]) ?? 0                                     VaultScore = ($propsFb['VaultScore'] -as [int]) ?? 0                                     RoleAssignmentsResolved = ($propsFb['RoleAssignmentsResolved'] -as [string]) ?? ''                                     JsonFilePath = $jsonPathFb                                 }                                 try { Write-AtomicJson -Path $jsonPathFb -Object $vaultExportFb -Depth 4 } catch { }                             }                         } catch { }                          $diagMsgsFb += ("Processed vault: {0}" -f (($propsFb['VaultName'] -as [string]) ?? ''))                         try { $localFinalFb += [PSCustomObject]$propsFb } catch { }                     }                     $invokeResult = @{ Results = $localFinalFb; Messages = $diagMsgsFb }                     $finalResults = $invokeResult.Results                     Write-Log "In-process final coercion fallback succeeded" -Level 'INFO'                 } catch {                     Write-Log "In-process final coercion fallback also failed: $($_.Exception.Message)" -Level 'ERROR'                 }             }             try {                 $diagPath = Join-Path -Path $outputDir -ChildPath ("final_coercion_diag_{0}.txt" -f (Get-Date).ToString('yyyy-MM-dd_HH-mm-ss'))                 $diag = [ordered]@{                     Timestamp = (Get-Date).ToString('o')                     Error = ($_.Exception.Message)                     FlattenedCount = ($flattenedResults.Count)                     FirstVaults = ($flattenedResults | Select-Object -First 20 | ForEach-Object { ($_).VaultName } | Where-Object { $_ } ) -join '; '                 }                 $diag | Out-File -FilePath $diagPath -Encoding UTF8                 Write-Log "Wrote final coercion diagnostic to: $diagPath" -Level 'INFO'                     Write-ProgressMarker ("WROTE_FINAL_COERCION_DIAG {0}" -f $diagPath)                  # Also write a fuller diagnostic into the repository workspace for easier inspection by developers                 try {                     $repoBase = Split-Path -Path $MyInvocation.MyCommand.Definition -Parent -ErrorAction SilentlyContinue                     if (-not $repoBase -or $repoBase -eq '') { $repoBase = Get-Location }                     $repoOutputDir = Join-Path -Path $repoBase 'output'                     if (-not (Test-Path $repoOutputDir)) { New-Item -ItemType Directory -Path $repoOutputDir -Force | Out-Null }                     $repoDiagPath = Join-Path -Path $repoOutputDir -ChildPath ("final_coercion_diag_full_{0}.json" -f (Get-Date).ToString('yyyy-MM-dd_HH-mm-ss'))                     try {                         $sample = $flattenedResults | Select-Object -First 50                         $sample | ConvertTo-Json -Depth 8 | Out-File -FilePath $repoDiagPath -Encoding UTF8 -Force                         Write-Log "Wrote extended final coercion diagnostic to workspace: $repoDiagPath" -Level 'INFO'                             Write-ProgressMarker ("WROTE_FINAL_COERCION_FULL {0}" -f $repoDiagPath)                     } catch {                         Write-Log "Failed to write extended final coercion diagnostic to workspace: $($_.Exception.Message)" -Level 'WARN'                     }                 } catch {                     # non-fatal                 }             } catch {                 Write-Log "Failed to write final coercion diagnostic: $($_.Exception.Message)" -Level 'WARN'             }             # Continue to HTML generation despite final coercion failure         }          # Recompute canonical unique QuickWins now (ensure it's up-to-date before HTML generation)         try {             $allWinTitles = @()             foreach ($v in $global:gapAnalysisResults) { foreach ($w in ($v.QuickWins)) { if ($w.Title) { $allWinTitles += $w.Title } } }             $uniqueWinTitles = @()             if ($allWinTitles.Count -gt 0) {                 $uniqueWinTitles = ($allWinTitles | ForEach-Object { $_.Trim() } | Where-Object { $_ -and $_ -ne '' } | ForEach-Object { $_.ToLowerInvariant() } | Sort-Object -Unique)             }             $global:uniqueWinTitles = $uniqueWinTitles             $global:TotalQuickWinsUnique = ($uniqueWinTitles).Count         } catch {             $global:uniqueWinTitles = @()             $global:TotalQuickWinsUnique = 0         }          # Pre-export parity check: ensure canonical unique QuickWins (computed earlier) matches parsed QuickWinsSummary         try {             $parsedTitles = @()             foreach ($row in $finalResults) {                 if ($row.QuickWinsSummary -and $row.QuickWinsSummary.Trim() -ne '') {                     $parts = $row.QuickWinsSummary -split ';' | ForEach-Object { $_.Trim() } | Where-Object { $_ -ne '' }                     $parsedTitles += $parts                 }             }             $parsedUnique = ($parsedTitles | ForEach-Object { $_.ToLowerInvariant() } | Sort-Object -Unique)             $parsedCount = ($parsedUnique).Count             if ($global:TotalQuickWinsUnique -ne $parsedCount) {                 Write-Log "Pre-export parity check failed: canonical unique quick wins ($($global:TotalQuickWinsUnique)) != parsed quick wins from CSV data ($parsedCount)" -Level "WARN"                 # Write a small reconciliation file to workspace for debugging                 try {                     $reconPath = Join-Path -Path (Split-Path -Path $csvPath -Parent) -ChildPath "quickwins_reconciliation_$((Get-Date).ToString('yyyy-MM-dd_HH-mm-ss')).csv"                     $reconObj = [PSCustomObject]@{                         CanonicalCount = $global:TotalQuickWinsUnique                         ParsedCount = $parsedCount                         CanonicalTitles = ($uniqueWinTitles -join '; ')                         ParsedTitles = ($parsedUnique -join '; ')                     }                     $reconObj | Export-Csv -Path $reconPath -NoTypeInformation -Encoding UTF8                     Write-Log "Wrote quick-wins reconciliation to: $reconPath" -Level "INFO"                 } catch {                     Write-Log "Failed to write quick-wins reconciliation file: $($_.Exception.Message)" -Level "WARN"                 }             } else {                 Write-Log "Pre-export parity check: canonical quick wins ($($global:TotalQuickWinsUnique)) == parsed quick wins ($parsedCount)" -Level "INFO"             }         } catch {             Write-Log "Pre-export parity check encountered an error: $($_.Exception.Message)" -Level "WARN"         }          Write-Log "Starting final CSV export to: $csvPath" -Level "INFO"         # Use background job with heartbeat and timeout to detect IO stalls\hangs         $csvTimeout = $global:CsvExportTimeoutSeconds         if (-not $csvTimeout -or $csvTimeout -le 0) { $csvTimeout = 600 } # default 10 minutes         try {             # Ensure a stable, canonical column order for CSV exports.             # Prefer an existing template CSV header (most recent KeyVaultComprehensiveAudit_*.csv in script dir) if available,             # otherwise use the union of property names from the final results.             $scriptDir = Split-Path -Path $MyInvocation.MyCommand.Definition -Parent             $templateCsv = Get-ChildItem -Path $scriptDir -Filter 'KeyVaultComprehensiveAudit_*.csv' -File -ErrorAction SilentlyContinue | Sort-Object LastWriteTime -Descending | Select-Object -First 1             if ($templateCsv) {                 try {                     $headerLine = (Get-Content -Path $templateCsv.FullName -TotalCount 1 -ErrorAction Stop)                     $headerLine = $headerLine.Trim()                     if ($headerLine.StartsWith('"') -and $headerLine.EndsWith('"')) { $headerLine = $headerLine.TrimStart('"').TrimEnd('"') }                     $preferredHeaders = $headerLine -split '","'                 } catch {                     $preferredHeaders = @()                 }             } else {                 $preferredHeaders = @()             }              if (-not $preferredHeaders -or $preferredHeaders.Count -eq 0) {                 # Fall back to union of properties found in the results (stable alphabetical order)                 $preferredHeaders = $finalResults | ForEach-Object { $_.PSObject.Properties.Name } | Sort-Object -Unique             }              # Select objects with the preferred header order; missing properties will be emitted as empty fields.             $exportSelection = $preferredHeaders             $toExport = $finalResults | Select-Object -Property $exportSelection             $toExport | Export-Csv -Path $csvPath -NoTypeInformation -Encoding UTF8 -Force             Write-Log "CSV export finished (file: $csvPath)" -Level 'SUCCESS'             Write-Log "HTML Report: $htmlPath" -Level "INFO"             Write-Log "CSV Data: $csvPath" -Level "INFO"         } catch {             Write-Log "CSV export FAILED: $($_.Exception.Message)" -Level "ERROR"             throw         }     } else {         Write-Log "No analysis results to export" -Level "WARNING"         # Create empty CSV with headers         $emptyResult = [PSCustomObject]@{             SubscriptionId = ""             VaultName = ""             Location = ""             ComplianceScore = 0             RiskLevel = ""             SecurityGapsCount = 0             QuickWinsCount = 0         }         $emptyResult | Export-Csv -Path $csvPath -NoTypeInformation -Encoding UTF8     }      # Generate HTML report     # Generate HTML in a child pwsh process with a timeout to avoid blocking the main run     $timeoutSec = $global:HtmlGenerationTimeoutSeconds     if (-not $timeoutSec -or $timeoutSec -le 0) { $timeoutSec = 120 }     Write-Log "Generating HTML report in child process (timeout ${timeoutSec}s)..." -Level "INFO"     # Avoid spawning the child HTML generator during focused SingleVault TestMode runs to prevent     # script re-entry and long re-discovery. Spawn the child only for broader runs.     if (-not $script:PreventChildHtmlSpawn) {         try {             $scriptFullPath = $MyInvocation.MyCommand.Definition             $tempDataPath = Join-Path -Path $env:TEMP -ChildPath ("akv_gap_html_data_$([guid]::NewGuid()).json")             $tempPlatformPath = Join-Path -Path $env:TEMP -ChildPath ("akv_gap_platform_$([guid]::NewGuid()).json")              try {                 Write-Log "Serializing analysis results for child HTML generation..." -Level 'INFO'                 Write-ProgressMarker ("START_NORMALIZE_FOR_JSON count={0}" -f ($global:gapAnalysisResults.Count))                 $normResults = Normalize-ForJson $global:gapAnalysisResults                 # Instrument serialization time                 $serializeSw = [System.Diagnostics.Stopwatch]::StartNew()                 $serialized = $null                 try {                     $opts = New-Object System.Text.Json.JsonSerializerOptions                     $opts.WriteIndented = $false                     $serialized = [System.Text.Json.JsonSerializer]::Serialize($normResults, $opts)                     $serialized | Out-File -FilePath $tempDataPath -Encoding UTF8 -Force                     $serializeSw.Stop()                     $serT = [math]::Round($serializeSw.Elapsed.TotalSeconds,2)                     Write-Log "Serialized analysis results using System.Text.Json -> $tempDataPath (took ${serT}s)" -Level 'INFO'                     Write-ProgressMarker ("SERIALIZED_SYSTEM_TEXT_JSON {0} took={1}s" -f $tempDataPath, $serT)                 } catch {                     $serializeSw.Stop()                     try {                         $serT = [math]::Round($serializeSw.Elapsed.TotalSeconds,2)                         Write-Log "System.Text.Json serialize failed after ${serT}s, falling back to ConvertTo-Json: $($_.Exception.Message)" -Level 'WARN'                         Write-ProgressMarker ("SYSTEM_TEXT_JSON_FAILED took={0}s err={1}" -f $serT, ($_.Exception.Message -replace '\r|\n',' '))                         $normResults | ConvertTo-Json -Depth 6 | Out-File -FilePath $tempDataPath -Encoding UTF8 -Force                         Write-Log "Serialized analysis results using ConvertTo-Json -> $tempDataPath" -Level 'INFO'                         Write-ProgressMarker ("SERIALIZED_CONVERTTOJSON {0}" -f $tempDataPath)                     } catch {                         Write-Log "Failed to serialize analysis results for child HTML generation: $($_.Exception.Message)" -Level "WARN"                         Write-ProgressMarker ("FAILED_SERIALIZE_FOR_HTML err={0}" -f ($_.Exception.Message -replace '\r|\n',' '))                         $tempDataPath = ''                     }                 }             } catch {                 Write-Log "Failed to prepare analysis results for HTML generation: $($_.Exception.Message)" -Level 'WARN'                 Write-ProgressMarker ("FAILED_PREPARE_ANALYSIS_FOR_HTML err={0}" -f ($_.Exception.Message -replace '\r|\n',' '))                 $tempDataPath = ''             }              try {                 $normPlatform = Normalize-ForJson $platformAssessments                 $normPlatform | ConvertTo-Json -Depth 8 | Out-File -FilePath $tempPlatformPath -Encoding UTF8             } catch {                 Write-Log "Failed to serialize platform assessments for child HTML generation: $($_.Exception.Message)" -Level "WARN"                 $tempPlatformPath = ''             }              # Launch the child script using a small temporary wrapper script which sets             # environment variables for the large JSON paths and then invokes the             # main script with a short argument list. This avoids Windows command-line             # length limits when passing long argument strings.             try {                 $guid = [guid]::NewGuid().ToString()                 $wrapperPath = Join-Path -Path $env:TEMP -ChildPath ("akv_html_launcher_{0}.ps1" -f $guid)                 $wrapperStdOut = Join-Path -Path $env:TEMP -ChildPath ("akv_html_child_stdout_{0}.log" -f $guid)                 $wrapperStdErr = Join-Path -Path $env:TEMP -ChildPath ("akv_html_child_stderr_{0}.log" -f $guid)                 $wrapperContent = @()                 # Set env vars inside the wrapper so the child can read them without long args                 $escapedData = $tempDataPath -replace "'","''"                 $escapedPlatform = $tempPlatformPath -replace "'","''"                 $escapedHtml = $htmlPath -replace "'","''"                 $wrapperContent += "`$env:AKV_HTML_DATA_PATH = '$escapedData'"                 $wrapperContent += "`$env:AKV_HTML_PLATFORM_PATH = '$escapedPlatform'"                 # Child output log paths                 $wrapperContent += "`$env:AKV_HTML_CHILD_STDOUT = '$wrapperStdOut'"                 $wrapperContent += "`$env:AKV_HTML_CHILD_STDERR = '$wrapperStdErr'"                 $wrapperContent += "# Invoke the main script in HTML-only mode; short arg list. Capture stdout\stderr to temp files."                 # Use explicit stream redirection so parent can inspect child logs later                 $invokeLine = "& pwsh -NoProfile -File '$scriptFullPath' -AKV_HTML_ONLY -AKV_HTML_OUTPUT_PATH '$escapedHtml' 1> '$wrapperStdOut' 2> '$wrapperStdErr'; exit `$LASTEXITCODE"                 $wrapperContent += $invokeLine                 $wrapperContent | Out-File -FilePath $wrapperPath -Encoding UTF8 -Force                 Write-ProgressMarker ("WROTE_HTML_WRAPPER {0}" -f $wrapperPath)                  Write-Log "Spawning child HTML generator via wrapper: $wrapperPath" -Level 'DEBUG'                 try { $pwshExe = (Get-Command pwsh -ErrorAction SilentlyContinue).Source } catch { $pwshExe = 'pwsh' }                 if (-not $pwshExe) { $pwshExe = 'pwsh' }                 Write-ProgressMarker ("STARTING_CHILD_PROCESS exe={0} wrapper={1}" -f $pwshExe, $wrapperPath)                 $proc = Start-Process -FilePath $pwshExe -ArgumentList @('-NoProfile','-File',$wrapperPath) -PassThru -WindowStyle Hidden             } catch {                 throw             }             # Instrument child process runtime to identify hangs with heartbeat logging             $procStart = Get-Date             $procSw = [System.Diagnostics.Stopwatch]::StartNew()             $heartbeat = 15             if ($global:HtmlGenerationHeartbeatSeconds -and ($global:HtmlGenerationHeartbeatSeconds -as [int]) -gt 0) { $heartbeat = [int]$global:HtmlGenerationHeartbeatSeconds }             $elapsed = 0             try {                 while (-not $proc.HasExited) {                     if ($proc.WaitForExit($heartbeat * 1000)) { break }                     $elapsed = [math]::Round($procSw.Elapsed.TotalSeconds,1)                     Write-Log "HTML generation still running after ${elapsed}s (heartbeat every ${heartbeat}s)" -Level 'INFO'                     if ($procSw.Elapsed.TotalSeconds -ge $timeoutSec) {                         Write-Log "HTML generation timed out after ${timeoutSec}s; terminating child process (ran ${elapsed}s)" -Level 'WARN'                         try { $proc.Kill() } catch { Write-Log "Failed to kill HTML generator process: $($_.Exception.Message)" -Level 'ERROR' }                         break                     }                 }                 $procSw.Stop()                 if ($proc.HasExited) {                     Write-Log "Child HTML generator exited (exitCode $($proc.ExitCode)) in $(([math]::Round($procSw.Elapsed.TotalSeconds, 2)))s" -Level "INFO"                     Write-ProgressMarker ("CHILD_EXITED exitCode={0} elapsed={1}s" -f $proc.ExitCode, [math]::Round($procSw.Elapsed.TotalSeconds,2))                 } else {                     Write-Log "Child HTML generator did not exit cleanly; it was terminated after $(([math]::Round($procSw.Elapsed.TotalSeconds,2)))s" -Level "WARN"                     Write-ProgressMarker ("CHILD_TERMINATED elapsed={0}s" -f [math]::Round($procSw.Elapsed.TotalSeconds,2))                 }             } catch {                 Write-Log "Error while waiting for child HTML generator: $($_.Exception.Message)" -Level 'ERROR'             }             # If the wrapper created child stdout\stderr files, copy them to the CSV\HTML output folder for diagnosis             try {                 $childLogDestDir = $null                 if ($csvPath) { $childLogDestDir = Split-Path -Path $csvPath -Parent }                 if (-not $childLogDestDir) { $childLogDestDir = Split-Path -Path $MyInvocation.MyCommand.Definition -Parent }                 if (Test-Path -Path $wrapperStdOut) {                     $destOut = Join-Path -Path $childLogDestDir -ChildPath ("child_html_stdout_{0}.log" -f $guid)                     Copy-Item -Path $wrapperStdOut -Destination $destOut -Force -ErrorAction SilentlyContinue                     Write-Log "Child HTML STDOUT saved to: $destOut" -Level 'DEBUG'                     Write-ProgressMarker ("COPIED_CHILD_STDOUT {0}" -f $destOut)                 }                 if (Test-Path -Path $wrapperStdErr) {                     $destErr = Join-Path -Path $childLogDestDir -ChildPath ("child_html_stderr_{0}.log" -f $guid)                     Copy-Item -Path $wrapperStdErr -Destination $destErr -Force -ErrorAction SilentlyContinue                     Write-Log "Child HTML STDERR saved to: $destErr" -Level 'DEBUG'                     Write-ProgressMarker ("COPIED_CHILD_STDERR {0}" -f $destErr)                 }             } catch {                 Write-Log "Failed copying child HTML log files for diagnosis: $($_.Exception.Message)" -Level 'WARN'             }             # If the child was terminated due to timeout, write a placeholder HTML so users still get an artifact             if ($proc -and -not $proc.HasExited -and $proc.ExitCode -eq $null) {                 # If process still exists and exit code unknown, assume it was terminated by us due to timeout                 $placeholder = "<!DOCTYPE html><html><head><meta charset='utf-8'><title>HTML generation timed out<\title><\head><body><h1>HTML generation timed out after ${timeoutSec}s<\h1><p>The full HTML report was not generated. Check logs for details.<\p><\body><\html>"                 try {                     $placeholder | Out-File -FilePath $htmlPath -Encoding UTF8                     Write-Log "Wrote placeholder HTML to $htmlPath" -Level "WARN"                 } catch {                     Write-Log "Failed to write placeholder HTML: $($_.Exception.Message)" -Level "ERROR"                 }             }              # Cleanup temp JSON files             try { if ($tempDataPath -and (Test-Path $tempDataPath)) { Remove-Item -Path $tempDataPath -Force -ErrorAction SilentlyContinue } } catch {}             try { if ($tempPlatformPath -and (Test-Path $tempPlatformPath)) { Remove-Item -Path $tempPlatformPath -Force -ErrorAction SilentlyContinue } } catch {}         } catch {             Write-Log "Failed to spawn child HTML generator: $($_.Exception.Message)" -Level "ERROR"         }     } else {         Write-Log "Skipping HTML child generation due to PreventChildHtmlSpawn flag (SingleVault+TestMode) to avoid re-entry" -Level 'INFO'     }      # Post-run: copy CSV and HTML into repository workspace for easier inspection (best-effort)     try {         # Prefer PSScriptRoot when running as a script; fallback to MyInvocation path when necessary         $repoBase = $PSScriptRoot         if (-not $repoBase -or $repoBase -eq '') {             $repoBase = Split-Path -Path $MyInvocation.MyCommand.Definition -Parent -ErrorAction SilentlyContinue         }         if (-not $repoBase -or $repoBase -eq '') { throw 'Unable to determine repository base path for workspace copy' }          $repoOutputDir = Join-Path $repoBase 'output'         if (!(Test-Path $repoOutputDir)) { New-Item -ItemType Directory -Path $repoOutputDir -Force | Out-Null }         $repoCsv = Join-Path $repoOutputDir (Split-Path -Path $csvPath -Leaf)         $repoHtml = Join-Path $repoOutputDir (Split-Path -Path $htmlPath -Leaf)         # Copy CSV         try {             Write-Log "Copying CSV to workspace: $repoCsv" -Level "INFO"             Copy-Item -Path $csvPath -Destination $repoCsv -Force -ErrorAction Stop             Write-Log "Copied CSV to workspace: $repoCsv" -Level "INFO"         } catch {             Write-Log "Failed to copy CSV to workspace: $($_.Exception.Message)" -Level "WARN"         }          # Copy HTML if present         try {             if (Test-Path $htmlPath) {                 Write-Log "Copying HTML to workspace: $repoHtml" -Level "INFO"                 Copy-Item -Path $htmlPath -Destination $repoHtml -Force -ErrorAction Stop                 Write-Log "Copied HTML to workspace: $repoHtml" -Level "INFO"             } else {                 Write-Log "HTML path not found, skipping workspace copy: $htmlPath" -Level "INFO"             }         } catch {             Write-Log "Failed to copy HTML to workspace: $($_.Exception.Message)" -Level "WARN"         }         Write-Log "Workspace copy attempts completed (best-effort) to: $repoOutputDir" -Level "INFO"     } catch {         # Non-fatal if copy fails (e.g., permissions or path issues) - continue silently     }      # Restore any altered global preferences (best-effort)     try {         if (Get-Variable -Name __prevWarningPreference -Scope Script -ErrorAction SilentlyContinue) {             $WarningPreference = $script:__prevWarningPreference             Remove-Variable -Name __prevWarningPreference -Scope Script -ErrorAction SilentlyContinue         }     } catch { }      # Summary     $endTime = Get-Date     $duration = $endTime - $StartTime      Write-Log "Gap analysis completed successfully!" -Level "SUCCESS"     Write-Log "Total vaults analyzed: $totalVaultsAnalyzed" -Level "INFO"     Write-Log "Execution time: $([math]::Round($duration.TotalMinutes, 1)) minutes" -Level "INFO"     Write-Log "Results saved to: $outputDir" -Level "INFO"     Write-Log "HTML Report: $htmlPath" -Level "INFO"     Write-Log "CSV Data: $csvPath" -Level "INFO"     Write-Log "Log File: $logPath" -Level "INFO"      # Cleanup run lock (best-effort) so future runs can start     if (-not $NoRunLock) {         if ($script:RunLockPath -and (Test-Path $script:RunLockPath)) {             try {                 $rawLock = Get-Content -Path $script:RunLockPath -ErrorAction SilentlyContinue -Raw                 $meta = $null                 if ($rawLock -and $rawLock.Trim() -ne '') {                 try {                     $meta = $rawLock | ConvertFrom-Json -ErrorAction SilentlyContinue                 } catch {                     $meta = $null                 }             }                 $shouldRemove = $false                 if ($meta -and $meta.PID) {                     if ($meta.PID -eq $PID) { $shouldRemove = $true }                 } else {                     # Unknown metadata - attempt removal                     $shouldRemove = $true                 }                 if ($shouldRemove) {                         Remove-Item -Path $script:RunLockPath -Force -ErrorAction SilentlyContinue                         Write-Log "Removed run lock: $script:RunLockPath" -Level 'INFO'                 } else {                     Write-Log "Did not remove run lock ($script:RunLockPath) owned by PID $($meta.PID)" -Level 'DEBUG'                 }             } catch {                 # fallback: attempt remove                 Remove-Item -Path $script:RunLockPath -Force -ErrorAction SilentlyContinue             }         }     } else {         Write-Log "NoRunLock was set for this run; skipping run-lock cleanup." -Level 'DEBUG'     }     catch {         # non-fatal     }     # Clear in-process sentinel     try {         $global:AkvGapAnalysis_InProcessRun = $false     } catch {     } ' is too long, or a component of the specified path is too long.
Split-Path: C:\Source\Github\powershell-akv-audit\Get-AKVGapAnalysis.ps1:5866:26
Line |
5866 |  … scriptDir = Split-Path -Path $MyInvocation.MyCommand.Definition -Pare …
     |                ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     | The path 'TestMode = $TestMode }         if ($PSBoundParameters.ContainsKey('Limit')) { $script:Limit = $Limit }  
     | if ($PSBoundParameters.ContainsKey('SubscriptionId')) { $script:SubscriptionId = $SubscriptionId }         if
     | ($PSBoundParameters.ContainsKey('OutputDirectory')) { $script:OutputDirectory = $OutputDirectory; if
     | ($OutputDirectory) { $script:outputDir = $OutputDirectory } }         if
     | ($PSBoundParameters.ContainsKey('SuppressAzureWarnings')) { $script:SuppressAzureWarnings = $SuppressAzureWarnings
     | }         if ($PSBoundParameters.ContainsKey('SingleVault')) { $script:SingleVault = $SingleVault }         if
     | ($PSBoundParameters.ContainsKey('VaultName')) { $script:VaultName = $VaultName }         if
     | ($PSBoundParameters.ContainsKey('SubscriptionName')) { $script:SubscriptionName = $SubscriptionName }         if
     | ($PSBoundParameters.ContainsKey('UseParallelProcessing')) { $script:UseParallelProcessing = $UseParallelProcessing
     | }         if ($PSBoundParameters.ContainsKey('MaxParallelJobs')) { $script:MaxParallelJobs = $MaxParallelJobs }   
     | if ($PSBoundParameters.ContainsKey('Resume')) { $script:Resume = $Resume }         if
     | ($PSBoundParameters.ContainsKey('SuppressModuleWarnings')) { $script:SuppressModuleWarnings =
     | $SuppressModuleWarnings }         if ($PSBoundParameters.ContainsKey('AutoInstallModules')) {
     | $script:AutoInstallModules = $AutoInstallModules }         if
     | ($PSBoundParameters.ContainsKey('DeepCrossReference')) { $script:DeepCrossReference = $DeepCrossReference }     if
     | ($PSBoundParameters.ContainsKey('SimulateInterruptAfter')) { $script:SimulateInterruptAfter =
     | $SimulateInterruptAfter }     if ($PSBoundParameters.ContainsKey('IncludeFunctionApps')) {
     | $script:IncludeFunctionApps = $IncludeFunctionApps }         if ($PSBoundParameters.ContainsKey('AKV_HTML_ONLY'))
     | { $script:AKV_HTML_ONLY = $AKV_HTML_ONLY }         if
     | ($PSBoundParameters.ContainsKey('FinalCoercionTimeoutSeconds')) { $script:FinalCoercionTimeoutSeconds =
     | $FinalCoercionTimeoutSeconds }         if ($PSBoundParameters.ContainsKey('FinalCoercionHeartbeatSeconds')) {
     | $script:FinalCoercionHeartbeatSeconds = $FinalCoercionHeartbeatSeconds }         if
     | ($PSBoundParameters.ContainsKey('AKV_HTML_DATA_PATH')) { $script:AKV_HTML_DATA_PATH = $AKV_HTML_DATA_PATH }       
     | if ($PSBoundParameters.ContainsKey('AKV_HTML_PLATFORM_PATH')) { $script:AKV_HTML_PLATFORM_PATH =
     | $AKV_HTML_PLATFORM_PATH }         if ($PSBoundParameters.ContainsKey('AKV_HTML_OUTPUT_PATH')) {
     | $script:AKV_HTML_OUTPUT_PATH = $AKV_HTML_OUTPUT_PATH }     } catch { $null }      # Normalize and reconcile
     | parameter values so logging and conditional logic     # use a single authoritative local value (handles
     | auto-splatting and script-level calls).     try {         if ($PSBoundParameters -and
     | $PSBoundParameters.ContainsKey('TestMode')) { $TestMode = [bool]$PSBoundParameters['TestMode'] }         elseif
     | ($script:TestMode) { $TestMode = [bool]$script:TestMode }          if ($PSBoundParameters -and
     | $PSBoundParameters.ContainsKey('Limit')) { $Limit = [int]$PSBoundParameters['Limit'] }         elseif
     | ($script:Limit) { $Limit = [int]$script:Limit }          if ($PSBoundParameters -and
     | $PSBoundParameters.ContainsKey('NoRunLock')) { $NoRunLock = [bool]$PSBoundParameters['NoRunLock'] }         elseif
     | ($script:NoRunLock) { $NoRunLock = [bool]$script:NoRunLock }          if ($PSBoundParameters -and
     | $PSBoundParameters.ContainsKey('UseParallelProcessing')) { $UseParallelProcessing =
     | [bool]$PSBoundParameters['UseParallelProcessing'] }         if ($PSBoundParameters -and
     | $PSBoundParameters.ContainsKey('MaxParallelJobs')) { $MaxParallelJobs = [int]$PSBoundParameters['MaxParallelJobs']
     | }     } catch { }      # Ensure local variables reflect script-level bound parameters (robustness when
     | auto-splatting)     try {         if ($PSBoundParameters -and $PSBoundParameters.ContainsKey('TestMode')) {
     | $TestMode = $PSBoundParameters['TestMode'] }         if ($PSBoundParameters -and
     | $PSBoundParameters.ContainsKey('Limit')) { $Limit = $PSBoundParameters['Limit'] }         if ($PSBoundParameters
     | -and $PSBoundParameters.ContainsKey('UseParallelProcessing')) { $UseParallelProcessing =
     | $PSBoundParameters['UseParallelProcessing'] }         if ($PSBoundParameters -and
     | $PSBoundParameters.ContainsKey('MaxParallelJobs')) { $MaxParallelJobs = $PSBoundParameters['MaxParallelJobs'] }   
     | if ($PSBoundParameters -and $PSBoundParameters.ContainsKey('Resume')) { $Resume = $PSBoundParameters['Resume'] }  
     | if ($PSBoundParameters -and $PSBoundParameters.ContainsKey('OutputDirectory')) { $OutputDirectory =
     | $PSBoundParameters['OutputDirectory']; if ($OutputDirectory) { $script:outputDir = $OutputDirectory } }         if
     | ($PSBoundParameters -and $PSBoundParameters.ContainsKey('NoRunLock')) { $NoRunLock =
     | $PSBoundParameters['NoRunLock'] }     } catch { }      # Prevent re-entrant calls in the same process: if the
     | function is already running,     # bail out early to avoid nested or recursive invocations that interfere with
     | locks.     if ($Force) {         $global:AkvGapAnalysis_InProcessRun = $false         Write-Log "Forced reset of
     | in-process run flag due to -Force parameter" -Level 'WARN'     }      try {         # Test-only bypass: if
     | AKV_FORCE_BYPASS_LOCK=1 in the environment, skip the         # early in-process sentinel check so a controlled
     | test run can proceed even         # while another run previously set the sentinel. This is intentionally         #
     | guarded by an explicit env var to avoid accidental bypass in production.         if ($env:AKV_FORCE_BYPASS_LOCK
     | -eq '1') {             Write-Log "AKV_FORCE_BYPASS_LOCK=1 detected — bypassing in-process sentinel check for test
     | run" -Level 'WARN'         } else {             if ($global:AkvGapAnalysis_InProcessRun) {                 #
     | Capture call stack for diagnostics                 try { $cs = Get-PSCallStack | Out-String -ErrorAction
     | SilentlyContinue } catch { $cs = 'Unable to capture call stack' }                 Write-Log "Invoke-GapAnalysis
     | called while another run is active in this process (PID: $PID) - skipping nested invocation. CallStack: $cs"
     | -Level 'WARN'                 return             }         }         $global:AkvGapAnalysis_InProcessRun = $true  
     | } catch { }      # If the user requested to suppress the noisy Azure module warnings, also     # silence
     | non-critical module discovery warnings to avoid log spam. This     # keeps the UX tidy when -SuppressAzureWarnings
     | is passed at the script     # invocation level (propagated via splatting below).     try {         if
     | ($SuppressAzureWarnings -and -not $SuppressModuleWarnings) { $SuppressModuleWarnings = $true }     } catch { }    
     | Write-Log "Starting Azure Key Vault Gap Analysis v$ScriptVersion" -Level "INFO"     Write-Log "Test Mode:
     | $TestMode" -Level "INFO"     if ($TestMode) { Write-Log "Test Limit: $Limit vaults" -Level "INFO" }      # Record
     | start time for reporting and duration calculations     $script:StartTime = Get-Date      # Lightweight run lock to
     | avoid accidental re-entry: create a lock file when a full     # run starts. Child\HTML-only runner sets
     | AKV_RUN_HTML_ONLY=1 and should not be     # blocked from generating HTML. If a lock already exists and we're not
     | an     # HTML-only runner, exit early to avoid starting a second full analysis.     # Respect explicit opt-out for
     | developers\testing: -NoRunLock skips run-lock creation\inspection.     if ($NoRunLock) {         Write-Log
     | "NoRunLock specified: skipping run-lock creation and inspection. This allows concurrent runs and may cause
     | duplicate work or race conditions. Use only for testing\development. To force a bypass in scripts without changing
     | parameters, set AKV_FORCE_BYPASS_LOCK=1 in the environment." -Level 'WARN'         # still set a canonical
     | RunLockPath variable so other code that references it won't error         $script:RunLockPath = Join-Path -Path
     | $env:TEMP -ChildPath 'akv_gap_analysis_running.lock'     } else {         try {             $script:RunLockPath =
     | Join-Path -Path $env:TEMP -ChildPath 'akv_gap_analysis_running.lock'             # TTL for run lock (seconds).
     | Default 1 hour.             if (-not $global:RunLockTtlSeconds) { $global:RunLockTtlSeconds = 3600 }            
     | $runLockTtl = [int]$global:RunLockTtlSeconds              # Respect a test-only bypass env var that allows forcing
     | a run even when a             # lock file or sentinel exists. This should only be used for short-lived            
     | # test runs and requires an explicit env var to enable.             if ($env:AKV_FORCE_BYPASS_LOCK -eq '1') {     
     | Write-Log "AKV_FORCE_BYPASS_LOCK=1 detected — bypassing run-lock file checks for test run" -Level 'WARN'          
     | }              if (-not ($env:AKV_FORCE_BYPASS_LOCK -eq '1')) {                 if (-not ($env:AKV_RUN_HTML_ONLY
     | -eq '1' -or ($script:AKV_HTML_ONLY -eq $true))) {                     if (Test-Path $script:RunLockPath) {        
     | # Try to read lock metadata to determine age                         try {                             $raw =
     | Get-Content -Path $script:RunLockPath -ErrorAction SilentlyContinue -Raw                             $meta = $null
     | if ($raw -and $raw.Trim() -ne '') {                                 try { $meta = $raw | ConvertFrom-Json
     | -ErrorAction SilentlyContinue } catch { $meta = $null }                             }                            
     | if ($meta -and $meta.StartedUtc) {                                 # Try ISO-8601 ('o') first, then fall back to a
     | general parse to be tolerant of other formats                                 $started = $null                    
     | try {                                     $ok = [datetime]::TryParseExact($meta.StartedUtc, 'o', $null,
     | [System.Globalization.DateTimeStyles]::RoundtripKind, [ref]$started)                                     if (-not
     | $ok) {                                         try { $started = [datetime]::Parse($meta.StartedUtc) } catch {
     | $started = $null }                                     }                                 } catch {                
     | try { $started = [datetime]::Parse($meta.StartedUtc) } catch { $started = $null }                                
     | }                                 if ($started) { $age = (Get-Date) - $started } else { $age = $null }            
     | if ($age.TotalSeconds -gt $runLockTtl) {                                     Write-Log "Found stale run lock (age:
     | $([math]::Round($age.TotalMinutes,1))m) at $script:RunLockPath - removing stale lock" -Level 'WARN'               
     | try { Remove-Item -Path $script:RunLockPath -Force -ErrorAction SilentlyContinue } catch { }                      
     | } else {                                     if ($age) {                                         # If the lock
     | metadata contains a PID, check whether that process is still running.                                        
     | $lockPid = $meta.PID                                         $proc = $null                                        
     | if ($lockPid) {                                             try { $proc = Get-Process -Id $lockPid -ErrorAction
     | SilentlyContinue } catch { $proc = $null }                                         }                              
     | if ($lockPid -and -not $proc) {                                             # The recorded PID is not running.
     | Allow an automatic bypass for test\resume flows                                             # or prompt the
     | interactive user to confirm removal. Non-interactive runs will be conservative                                    
     | # and will not remove the lock unless -Resume is provided or the test env var is set.                             
     | if ($Resume -or ($env:AKV_FORCE_BYPASS_LOCK -eq '1')) {                                                 Write-Log
     | "Run lock at $script:RunLockPath refers to PID $lockPid which is not running; removing lock due to
     | -Resume\AKV_FORCE_BYPASS_LOCK" -Level 'WARN'                                                 try { Remove-Item
     | -Path $script:RunLockPath -Force -ErrorAction SilentlyContinue } catch { }                                        
     | } else {                                                 $confirmed = $false                                      
     | try {                                                     # Attempt an interactive prompt; if Read-Host fails
     | (non-interactive), fall through to exit.                                                     $prompt = "Detected
     | run lock for PID $lockPid (started $($meta.StartedUtc)) but that process is not running. Remove lock and continue?
     | [y\N]"                                                     $answer = Read-Host -Prompt $prompt                    
     | if ($answer -and $answer.Trim().ToUpper().StartsWith('Y')) { $confirmed = $true }                                 
     | } catch {                                                     # Non-interactive host; cannot prompt. Do not remove
     | lock.                                                     $confirmed = $false                                     
     | }                                                 if ($confirmed) {                                               
     | Write-Log "User confirmed removal of run lock for PID $lockPid; removing and continuing" -Level 'WARN'            
     | try { Remove-Item -Path $script:RunLockPath -Force -ErrorAction SilentlyContinue } catch { }                      
     | } else {                                                     Write-Log "Run-lock present and user did not confirm
     | removal; exiting to avoid duplicate work." -Level 'WARN'                                                    
     | return                                                 }                                             }            
     | } else {                                             if ($age) {                                                
     | Write-Log "Detected existing run lock ($script:RunLockPath) created by PID $($meta.PID) at $($meta.StartedUtc).
     | Another run appears active — exiting to avoid duplicate work." -Level 'WARN'                                      
     | } else {                                                 Write-Log "Detected existing run lock
     | ($script:RunLockPath) with unparsable StartedUtc ('$($meta.StartedUtc)'). Treating as active and exiting to avoid
     | duplicate work." -Level 'WARN'                                             }                                      
     | return                                         }                                     } else {                     
     | # Unknown lock contents; be conservative and exit                                         Write-Log "Detected
     | existing run lock ($script:RunLockPath) with unknown metadata. Another run may be active — exiting to avoid
     | duplicate work." -Level 'WARN'                                         return                                    
     | }                                 }                             } else {                                 # Unknown
     | lock contents; be conservative and exit                                 Write-Log "Detected existing run lock
     | ($script:RunLockPath) with unknown metadata. Another run may be active — exiting to avoid duplicate work." -Level
     | 'WARN'                                 return                             }                         } catch {     
     | Write-Log "Error while inspecting run lock ($script:RunLockPath): $($_.Exception.Message) - exiting to avoid
     | duplicate work" -Level 'WARN'                             return                         }                     }  
     | # Create a lock file with metadata                     try {                         $lockMeta = [ordered]@{      
     | PID = $PID                             Owner = $env:USERNAME                             StartedUtc =
     | (Get-Date).ToString('o')                             Command = ($MyInvocation.MyCommand.Definition -as [string])  
     | }                         $lockMeta | ConvertTo-Json -Depth 4 | Out-File -FilePath $script:RunLockPath -Encoding
     | UTF8 -Force                         # Use INFO level here because Write-Log ValidateSet may not accept DEBUG in
     | some contexts                         Write-Log "Created run lock at: $script:RunLockPath (PID: $PID)" -Level
     | 'INFO'                     } catch {                         Write-Log "Failed to create run lock
     | ($script:RunLockPath): $($_.Exception.Message) - continuing without lock" -Level 'WARN'                     }     
     | }             }         } catch {             # best-effort: if lock cannot be created or inspected, continue     
     | }     }          # Debug: print canonical effective runtime parameters for visibility (useful when dot-sourced)   
     | try {         $debugParams = [PSCustomObject]@{             TestMode = $TestMode             Limit = $Limit       
     | UseParallelProcessing = $UseParallelProcessing             MaxParallelJobs = $MaxParallelJobs             Resume =
     | $Resume         }         Write-Log ("Effective parameters: TestMode={0} Limit={1} UseParallelProcessing={2}
     | MaxParallelJobs={3} Resume={4}" -f $debugParams.TestMode, $debugParams.Limit, $debugParams.UseParallelProcessing,
     | $debugParams.MaxParallelJobs, $debugParams.Resume) -Level 'INFO'     } catch { }          # If the caller
     | requested suppression of Azure warnings, reduce global         # warning noise for the duration of this run by
     | setting WarningPreference         # to SilentlyContinue. We restore it at the end of the run.         try {       
     | if ($SuppressAzureWarnings) {                 $script:__prevWarningPreference = $WarningPreference                
     | $WarningPreference = 'SilentlyContinue'             }         } catch { }          # If invoked as HTML-only child
     | via parameter, populate legacy env vars so the         # existing HTML-only branch (which checks
     | $env:AKV_RUN_HTML_ONLY) continues to work.         try {             if ($AKV_HTML_ONLY) {                
     | Write-Log "HTML-only invocation detected via -AKV_HTML_ONLY; setting legacy env vars for compatibility" -Level
     | 'INFO'                 $env:AKV_RUN_HTML_ONLY = '1'                 if ($AKV_HTML_DATA_PATH) {
     | $env:AKV_HTML_DATA_PATH = $AKV_HTML_DATA_PATH }                 if ($AKV_HTML_PLATFORM_PATH) {
     | $env:AKV_HTML_PLATFORM_PATH = $AKV_HTML_PLATFORM_PATH }                 if ($AKV_HTML_OUTPUT_PATH) {
     | $env:AKV_HTML_OUTPUT_PATH = $AKV_HTML_OUTPUT_PATH }             }         } catch { }      # Prepare a path for a
     | test-mode reservation counter so parallel runspaces can atomically reserve slots     try {        
     | $testCounterPath = Join-Path -Path $outputDir -ChildPath 'testmode_counter.txt'         # Reset counter at run
     | start when starting fresh (not resuming)         if ($TestMode -and -not $Resume) {             try { if
     | (Test-Path $testCounterPath) { Remove-Item -Path $testCounterPath -Force -ErrorAction SilentlyContinue } } catch {
     | }         }     } catch { $testCounterPath = Join-Path -Path $env:TEMP -ChildPath ('testmode_counter_{0}.txt' -f
     | ([guid]::NewGuid().ToString())) }      # Load or initialize checkpoint in memory so Save-Checkpoint-Atomic can use
     | it     try {         $global:checkpoint = Load-Checkpoint         if ($null -eq $global:checkpoint) {
     | $global:checkpoint = @{} }     } catch { $global:checkpoint = @{} }     # Create a worker id for this process
     | (used for parallel-safe incremental CSV temp files)     try { $global:WorkerId = "${env:COMPUTERNAME}_${PID}" }
     | catch { $global:WorkerId = ([guid]::NewGuid().ToString()) }      # Install CTRL-C \ CancelKeyPress handler if
     | available to allow graceful shutdown     try {         if ([console] -and [console].PSIsContainer -ne $null -and
     | ([console] | Get-Member -Name 'CancelKeyPress' -MemberType Event -ErrorAction SilentlyContinue)) {            
     | Register-EngineEvent -SourceIdentifier Console_CancelKeyPress -SupportEvent -Action {                 Write-Log
     | "CTRL-C detected: requesting graceful shutdown..." -Level 'WARN'                 $global:ScriptStopRequested =
     | $true                 try {                     # If a vault is currently in-progress (sequential mode), mark it
     | as processed with a partial marker                     if ($null -ne $global:currentVaultInProgress -and
     | $global:currentVaultInProgress -ne '') {                         try {                             Write-Log
     | "Marking in-progress vault ($global:currentVaultInProgress) as partially processed in checkpoint." -Level 'INFO'  
     | if (Get-Command -Name Mark-Vault-Processed -ErrorAction SilentlyContinue) {                                
     | Mark-Vault-Processed -VaultResourceId $global:currentVaultInProgress -JsonFilePath ''                            
     | }                         } catch { }                     }                     # persist the current checkpoint
     | state if any                     if (Get-Command -Name Save-Checkpoint-Atomic -ErrorAction SilentlyContinue) {    
     | $state = Load-Checkpoint                         Save-Checkpoint-Atomic -State $state                        
     | Write-Log "Checkpoint saved during shutdown." -Level 'INFO'                     }                 } catch { }     
     | } | Out-Null         }     } catch { }      # Initialize authentication     if (!(Initialize-AzureAuthentication))
     | {         Write-Log "Authentication failed. Exiting." -Level "ERROR"         exit 1     }      # Capture Azure
     | context for parallel processing     $azContext = Get-AzContext     if ($SingleVault) {         Write-Log "Single
     | Vault Mode: Analyzing $VaultName" -Level "INFO"          # Find the subscription containing the vault        
     | $targetSubscription = $null         $foundVault = $null          if ($SubscriptionName) {             # User
     | specified subscription name             Write-Log "Looking up subscription by name: $SubscriptionName
     | (Get-AzSubscription)" -Level 'DEBUG'             $targetSubscription = Get-AzSubscription | Where-Object { $_.Name
     | -eq $SubscriptionName }             if (-not $targetSubscription) {                 Write-Log "Specified
     | subscription '$SubscriptionName' not found" -Level "ERROR"                 exit 1             }         } else {  
     | # Auto-discover subscription containing the vault             Write-Log "Auto-discovering subscription containing
     | vault '$VaultName'..." -Level "INFO"             Write-Log "About to call Get-AzSubscription for auto-discovery"
     | -Level 'DEBUG'             $subscriptionsToCheck = Get-AzSubscription | Where-Object { $_.State -eq 'Enabled' }   
     | foreach ($sub in $subscriptionsToCheck) {                 Write-Log "Setting Az context to subscription
     | $($sub.Name) ($($sub.Id)) before checking for vault" -Level 'DEBUG'                 Set-AzContext -SubscriptionId
     | $sub.Id | Out-Null                 try {                     Write-Log "Probing Get-AzKeyVault -VaultName
     | $VaultName in subscription $($sub.Name)" -Level 'DEBUG'                     $vault = Get-AzKeyVault -VaultName
     | $VaultName -ErrorAction Stop                     $targetSubscription = $sub                     $foundVault =
     | $vault                     Write-Log "Found vault '$VaultName' in subscription '$($sub.Name)'" -Level "SUCCESS"   
     | break                 } catch {                     # Vault not in this subscription, continue                    
     | Write-Log "Vault not in subscription $($sub.Name) or not accessible: $($_.Exception.Message)" -Level "DEBUG"      
     | }             }         }          if (-not $targetSubscription) {             Write-Log "Vault '$VaultName' not
     | found in any accessible subscription" -Level "ERROR"             exit 1         }          # Get the vault if not
     | already found         if (-not $foundVault) {             Set-AzContext -SubscriptionId $targetSubscription.Id |
     | Out-Null             try {                 $foundVault = Get-AzKeyVault -VaultName $VaultName             } catch
     | {                 Write-Log "Failed to retrieve vault '$VaultName': $($_.Exception.Message)" -Level "ERROR"       
     | exit 1             }         }          # Create single-item arrays for processing         $subscriptions =
     | @($targetSubscription)         $keyVaults = @($foundVault)          Write-Log "Single Vault Analysis: $VaultName
     | in subscription $($targetSubscription.Name)" -Level "INFO"     } else {         # Get subscriptions to analyze    
     | $subscriptions = Get-SubscriptionsToAnalyze         if ($subscriptions.Count -eq 0) {             Write-Log "No
     | subscriptions found or accessible. Exiting." -Level "ERROR"             exit 1         }     }     
     | $totalVaultsAnalyzed = 0     $platformAssessments = @()     $vaultsProcessedInTestMode = 0      # Initialize
     | global variables for this run     $global:gapAnalysisResults = @()     $global:securityGaps = @()    
     | $global:quickWins = @()     $global:recommendations = @()      # Load checkpoint if resume requested    
     | $checkpoint = @{}     if ($Resume) {         Write-Log "Resume requested - loading checkpoint if present" -Level
     | "INFO"         $checkpoint = Load-Checkpoint         if (-not $checkpoint) { $checkpoint = @{} }     }      #
     | Analyze each subscription     foreach ($subscription in $subscriptions) {         # If a graceful stop was
     | requested (CTRL-C), break out of subscription processing         if ($global:ScriptStopRequested) {            
     | Write-Log "Script stop requested - aborting further subscription processing" -Level 'WARN'             break      
     | }         # If TestMode limit already reached, stop processing further subscriptions immediately         if
     | ($TestMode -and $vaultsProcessedInTestMode -ge $Limit) {             Write-Log "Test mode limit ($Limit) already
     | reached; stopping subscription processing" -Level 'INFO'             break         }          # Short-circuit
     | scanning for TestMode: first probe for Key Vaults and only         # perform heavier platform assessment work if
     | this subscription contains         # vaults we intend to analyze. This keeps TestMode quick by using the         #
     | minimum number of subscriptions necessary to satisfy -Limit.         Write-Log "Analyzing subscription:
     | $($subscription.Name) ($($subscription.Id))" -Level "INFO"          # If SingleVault and this isn't the target
     | subscription, skip         if ($SingleVault -and $subscription.Id -ne $targetSubscription.Id) { continue }        
     | # Discover vaults first when in TestMode to avoid scanning many subscriptions         if (-not $SingleVault) {    
     | $keyVaults = Get-KeyVaultsInSubscription -SubscriptionId $subscription.Id              if ($keyVaults.Count -eq 0)
     | {                 Write-Log "No Key Vaults found in subscription $($subscription.Name)" -Level "INFO"             
     | continue             }              # If resuming, filter out vaults already processed per checkpoint            
     | if ($Resume -and $checkpoint.Processed) {                 $keyVaults = $keyVaults | Where-Object { -not
     | $checkpoint.Processed.ContainsKey($_.ResourceId) }                 Write-Log "Resume mode: skipping
     | $([math]::Max(0, ($keyVaults.Count))) already-processed vaults in subscription $($subscription.Name)" -Level
     | "INFO"             }              # Apply test-mode global limit if TestMode is enabled             if ($TestMode)
     | {                 $remainingLimit = $Limit - $vaultsProcessedInTestMode                 if ($remainingLimit -le 0)
     | {                     Write-Log "Test mode limit ($Limit) reached, skipping remaining subscriptions" -Level "INFO"
     | break                 }                  if ($keyVaults.Count -gt $remainingLimit) {                    
     | $keyVaults = $keyVaults | Select-Object -First $remainingLimit                     Write-Log "Test mode: Limited
     | to $remainingLimit vaults in this subscription" -Level "INFO"                 }             }         }          #
     | For SingleVault mode, $keyVaults is already set above         if ($TestMode -and -not $SingleVault -and
     | $keyVaults.Count -gt ($Limit - $vaultsProcessedInTestMode)) {             $remainingLimit = $Limit -
     | $vaultsProcessedInTestMode             $keyVaults = $keyVaults | Select-Object -First $remainingLimit            
     | Write-Log "Test mode: Limited to $remainingLimit vaults in this subscription" -Level "INFO"         }          #
     | Now that we know this subscription contains vault(s) we care about,         # perform the (heavier) Azure platform
     | assessment and continue.         $platformAssessment = Get-AzurePlatformAssessment -SubscriptionId
     | $subscription.Id         $platformAssessments += $platformAssessment          # Analyze each vault         if
     | ($UseParallelProcessing -and $env:OS -notlike "*Windows*") {             Write-Log "Parallel processing is only
     | supported on Windows. Falling back to sequential processing." -Level "WARNING"             $UseParallelProcessing
     | = $false         }          if ($UseParallelProcessing) {             Write-Log "Using parallel processing with
     | max $MaxParallelJobs concurrent jobs" -Level "INFO"              # Create vault analysis jobs            
     | $vaultJobs = $keyVaults | ForEach-Object -ThrottleLimit $MaxParallelJobs -Parallel {                 $vault = $_  
     | $subscriptionId = $using:subscription.Id                 $subscriptionName = $using:subscription.Name             
     | # Re-establish Azure context in parallel job                 $azContext = $using:azContext                 if
     | ($azContext) {                     try {                         Set-AzContext -Context $azContext | Out-Null     
     | } catch {                         # Context sharing failed, try alternative authentication                        
     | Write-Log "Parallel job: failed to set Az context in job for subscription ${subscriptionId}:
     | $($_.Exception.Message)" -Level "DEBUG"                         try {                             $null =
     | Connect-AzAccount -Identity -ErrorAction Stop                         } catch {                            
     | Write-Log "Parallel job: Connect-AzAccount -Identity also failed: $($_.Exception.Message)" -Level "DEBUG"         
     | # If both methods fail, we'll proceed without context and handle errors gracefully                         }      
     | }                 }                  # Test-mode: attempt an atomic reservation before doing any work in this job 
     | try {                     if ($using:TestMode) {                         $reserved = $false                       
     | try {                             $reserved = Try-Reserve-TestSlot -Limit $using:Limit -CounterPath
     | $using:testCounterPath                         } catch {                             $reserved = $false           
     | }                         if (-not $reserved) {                             Write-Log ("Test mode: global limit
     | reached; parallel job skipping vault: $($vault.VaultName)") -Level 'INFO'                             return      
     | } else {                             Write-Log ("Test mode: reserved slot for vault: $($vault.VaultName)") -Level
     | 'DEBUG'                         }                     }                 } catch { }                  try {        
     | # Get diagnostics configuration                     $diagnostics = & {                         param($vaultName,
     | $rgName)                         try {                             $diag = Get-AzDiagnosticSetting -ResourceId
     | "\subscriptions\$subscriptionId\resourceGroups\$rgName\providers\Microsoft.KeyVault\vaults\$vaultName"
     | -ErrorAction SilentlyContinue                             return @{                                 HasDiagnostics
     | = ($diag.Count -gt 0)                                 DiagnosticSettings = $diag                                
     | LogsEnabled = ($diag | Where-Object { $_.Logs.Count -gt 0 }).Count -gt 0                                
     | MetricsEnabled = ($diag | Where-Object { $_.Metrics.Count -gt 0 }).Count -gt 0                             }      
     | } catch {                             return @{                                 HasDiagnostics = $false           
     | DiagnosticSettings = $null                                 LogsEnabled = $false                                
     | MetricsEnabled = $false                             }                         }                     }
     | $vault.VaultName $vault.ResourceGroupName                      # Get access control analysis                    
     | $accessControl = & {                         param($vaultName, $rgName, $subId)                         try {     
     | $vaultObj = Get-AzKeyVault -VaultName $vaultName -ResourceGroupName $rgName                            
     | $rbacEnabled = $vaultObj.EnableRbacAuthorization                             $accessPolicies =
     | $vaultObj.AccessPolicies                             $roleAssignments = Get-AzRoleAssignment -Scope
     | $vaultObj.ResourceId -ErrorAction SilentlyContinue                              return @{                         
     | RbacEnabled = $rbacEnabled                                 AccessPoliciesCount = $accessPolicies.Count            
     | RoleAssignmentsCount = $roleAssignments.Count                                 HasAccessPolicies =
     | ($accessPolicies.Count -gt 0)                                 HasRoleAssignments = ($roleAssignments.Count -gt 0) 
     | }                         } catch {                             return @{                                
     | RbacEnabled = $null                                 AccessPoliciesCount = 0                                
     | RoleAssignmentsCount = 0                                 HasAccessPolicies = $false                               
     | HasRoleAssignments = $false                             }                         }                     }
     | $vault.VaultName $vault.ResourceGroupName $subscriptionId                      # Get network security analysis    
     | $networkSecurity = & {                         param($vaultName, $rgName)                         try {           
     | $vaultObj = Get-AzKeyVault -VaultName $vaultName -ResourceGroupName $rgName                            
     | $networkAcls = $vaultObj.NetworkAcls                             $privateEndpoints = Get-AzPrivateEndpoint |
     | Where-Object {                                 $_.PrivateLinkServiceConnections.PrivateLinkServiceId -like
     | "*$vaultName*"                             }                              return @{                               
     | PublicNetworkAccess = $vaultObj.PublicNetworkAccess                                 NetworkAclsConfigured = ($null
     | -ne $networkAcls)                                 PrivateEndpointsCount = $privateEndpoints.Count                 
     | HasPrivateEndpoints = ($privateEndpoints.Count -gt 0)                                 TrustedServicesEnabled =
     | $networkAcls.Bypass -contains "AzureServices"                             }                         } catch {     
     | return @{                                 PublicNetworkAccess = $null                                
     | NetworkAclsConfigured = $false                                 PrivateEndpointsCount = 0                          
     | HasPrivateEndpoints = $false                                 TrustedServicesEnabled = $false                      
     | }                         }                     } $vault.VaultName $vault.ResourceGroupName                      #
     | Calculate compliance score and identify gaps                     $gaps = @()                     $wins = @()      
     | # Security gap identification logic                     if (!$accessControl.RbacEnabled -and
     | $accessControl.AccessPoliciesCount -eq 0) {                         $gaps += @{                            
     | Category = "Access Control"                             Severity = "Critical"                             Issue =
     | "No access control configured"                             Impact = "Vault is inaccessible"                       
     | Recommendation = "Enable RBAC or configure access policies"                         }                     }       
     | if (!$diagnostics.HasDiagnostics) {                         $gaps += @{                             Category =
     | "Monitoring"                             Severity = "High"                             Issue = "No diagnostic
     | settings configured"                             Impact = "No audit logging or monitoring"                        
     | Recommendation = "Enable diagnostic settings to Log Analytics or Event Hub"                         }             
     | }                      if ($networkSecurity.PublicNetworkAccess -eq "Enabled" -and
     | !$networkSecurity.HasPrivateEndpoints) {                         $gaps += @{                             Category
     | = "Network Security"                             Severity = "Medium"                             Issue = "Public
     | network access enabled without private endpoints"                             Impact = "Potential exposure to
     | public internet"                             Recommendation = "Configure private endpoints or restrict network
     | access"                         }                     }                      # Quick wins logic                   
     | if ($accessControl.AccessPoliciesCount -gt 0 -and !$accessControl.RbacEnabled) {                         $wins +=
     | @{                             Category = "Access Control"                             Title = "Migrate to RBAC"  
     | Description = "Replace access policies with Azure RBAC for better security and management"                        
     | Effort = "Medium"                             Impact = "High"                         }                     }     
     | if (!$diagnostics.HasDiagnostics) {                         $wins += @{                             Category =
     | "Monitoring"                             Title = "Enable Diagnostic Logging"                            
     | Description = "Configure diagnostic settings to capture audit logs and metrics"                             Effort
     | = "Low"                             Impact = "High"                         }                     }               
     | # Calculate compliance score                     $score = 100                     foreach ($gap in $gaps) {       
     | switch ($gap.Severity) {                             "Critical" { $score -= 25 }                            
     | "High" { $score -= 15 }                             "Medium" { $score -= 10 }                             "Low" {
     | $score -= 5 }                         }                     }                      # Bonus points                 
     | if ($diagnostics.HasDiagnostics) { $score += 10 }                     if ($accessControl.RbacEnabled) { $score +=
     | 10 }                     if ($networkSecurity.HasPrivateEndpoints) { $score += 10 }                     
     | $complianceScore = [math]::Max(0, [math]::Min(100, $score))                     $riskLevel = switch
     | ($complianceScore) {                         { $_ -ge 90 } { "Low" }                         { $_ -ge 70 } {
     | "Medium" }                         { $_ -ge 50 } { "High" }                         default { "Critical" }        
     | }                      return @{                         SubscriptionId = $subscriptionId                        
     | SubscriptionName = $subscriptionName                         VaultName = $vault.VaultName                        
     | ResourceGroupName = $vault.ResourceGroupName                         Location = $vault.Location                   
     | Diagnostics = $diagnostics                         AccessControl = $accessControl                        
     | NetworkSecurity = $networkSecurity                         SecurityGaps = $gaps                         QuickWins
     | = $wins                         ComplianceScore = $complianceScore                         RiskLevel = $riskLevel 
     | Vault = $vault                         WorkerId = "$($env:COMPUTERNAME)_$PID"                     }               
     | } catch {                     return @{                         SubscriptionId = $subscriptionId                  
     | SubscriptionName = $subscriptionName                         VaultName = $vault.VaultName                        
     | ResourceGroupName = $vault.ResourceGroupName                         Location = $vault.Location                   
     | Diagnostics = @{ HasDiagnostics = $false }                         AccessControl = @{ RbacEnabled = $false;
     | AccessPoliciesCount = 0; RoleAssignmentsCount = 0 }                         NetworkSecurity = @{
     | HasPrivateEndpoints = $false }                         SecurityGaps = @(@{ Category = "Error"; Severity = "High";
     | Issue = "Analysis failed: $($_.Exception.Message)" })                         QuickWins = @()                     
     | ComplianceScore = 0                         RiskLevel = "Critical"                         Vault = $vault         
     | WorkerId = "$($env:COMPUTERNAME)_$PID"                     }                 }             }              #
     | Collect results from parallel jobs             foreach ($result in $vaultJobs) {                 if
     | ($global:ScriptStopRequested) {                     Write-Log "Script stop requested - halting collection of
     | parallel results" -Level 'WARN'                     break                 }                
     | $global:gapAnalysisResults += $result                 $totalVaultsAnalyzed++                
     | $vaultsProcessedInTestMode++                  # persist per-vault JSON\marker if available                 try {  
     | if ($result.Vault -and $result.Vault.ResourceId) {                         Write-Log "Finished analysis of
     | $($result.VaultName) - persisting marker and checkpoint" -Level 'INFO'                         $jsonPath = $null  
     | if ($result.JsonFilePath) { $jsonPath = $result.JsonFilePath }                         Mark-Vault-Processed
     | -VaultResourceId $result.Vault.ResourceId -JsonFilePath $jsonPath                         # Immediately persist
     | checkpoint for recoverability                         try { Save-Checkpoint-Atomic -State $global:checkpoint }
     | catch { Write-Log "Checkpoint save failed: $($_.Exception.Message)" -Level 'WARN' }                         #
     | Append to incremental CSV. When running in parallel, write to a per-worker temp                         try {     
     | $row = Build-MasterCsvRecord -Analysis $result                             if ($UseParallelProcessing) {          
     | $wId = $null                                 if ($result.PSObject.Properties.Name -contains 'WorkerId') { $wId =
     | $result.WorkerId }                                 Append-IncrementalCsvRow -Row $row -WorkerId $wId              
     | } else {                                 Append-IncrementalCsvRow -Row $row                             }         
     | } catch {                             # Non-fatal: continue on append errors                         }            
     | }                 } catch { }                  Write-Log "Completed parallel analysis of $($result.VaultName) -
     | Score: $($result.ComplianceScore)%, Risk: $($result.RiskLevel)" -Level "INFO"                  # Check if we've
     | reached the overall limit                 if ($TestMode -and $vaultsProcessedInTestMode -ge $Limit) {             
     | Write-Log "Test mode limit ($Limit) reached, stopping analysis" -Level "INFO"                     break           
     | }                  # Simulate an interrupt for testing if requested                 if ($SimulateInterruptAfter
     | -and $SimulateInterruptAfter -gt 0 -and $vaultsProcessedInTestMode -ge $SimulateInterruptAfter) {                 
     | Write-Log "SimulateInterruptAfter threshold reached ($SimulateInterruptAfter) - saving checkpoint and setting stop
     | flag" -Level "WARN"                     $global:ScriptStopRequested = $true                     try {             
     | try {                             Save-Checkpoint-Atomic -State $global:checkpoint                            
     | Write-Log "Checkpoint saved to: $(Get-CheckpointPath)" -Level "INFO"                         } catch {            
     | Write-Log "Save-Checkpoint-Atomic failed: $($_.Exception.Message)" -Level 'ERROR'                         }       
     | } catch {                         Write-Log "Failed to save checkpoint during simulated interrupt:
     | $($_.Exception.Message)" -Level "ERROR"                     }                     break                 }         
     | # Simulation: optionally trigger an interrupt after N processed vaults                 if ($SimulateInterruptAfter
     | -gt 0 -and $vaultsProcessedInTestMode -ge $SimulateInterruptAfter) {                     Write-Log
     | "SimulateInterruptAfter reached ($SimulateInterruptAfter) - simulating CTRL-C and saving checkpoint" -Level 'WARN'
     | $global:ScriptStopRequested = $true                     try { Save-Checkpoint-Atomic -State $global:checkpoint }
     | catch { }                     break                 }             }         } else {             # Sequential
     | processing (original logic)             foreach ($vault in $keyVaults) {                 if
     | ($global:ScriptStopRequested) {                     Write-Log "Script stop requested - aborting sequential vault
     | processing" -Level 'WARN'                     break                 }                 # mark current in-progress
     | vault so CTRL-C handler can persist a partial checkpoint if needed                 $global:currentVaultInProgress
     | = $vault.ResourceId                  # Test-mode: attempt an atomic reservation before processing this vault (only
     | for parallel processing)                 if ($TestMode -and $UseParallelProcessing) {                     try {   
     | $reserved = Try-Reserve-TestSlot -Limit $Limit -CounterPath $testCounterPath                     } catch {        
     | $reserved = $false                     }                     if (-not $reserved) {                        
     | Write-Log "Test mode: global limit reached; skipping remaining vaults" -Level 'INFO'                         break
     | } else {                         Write-Log ("Test mode: reserved slot for vault: $($vault.VaultName)") -Level
     | 'DEBUG'                     }                 }                 $analysis = Analyze-KeyVault -Vault $vault
     | -SubscriptionId $subscription.Id -SubscriptionName $subscription.Name                 $global:gapAnalysisResults
     | += $analysis                 $totalVaultsAnalyzed++                 $vaultsProcessedInTestMode++                 
     | # persist per-vault JSON\marker                 try {                     if ($analysis.Vault -and
     | $analysis.Vault.ResourceId) {                         Write-Log "Finished analysis of $($analysis.Vault.VaultName)
     | - persisting marker and checkpoint" -Level 'INFO'                         $jsonPath = $null                       
     | if ($analysis.JsonFilePath) { $jsonPath = $analysis.JsonFilePath }                         Mark-Vault-Processed
     | -VaultResourceId $analysis.Vault.ResourceId -JsonFilePath $jsonPath                         # clear in-progress
     | marker now that vault completed successfully                         $global:currentVaultInProgress = $null       
     | # Immediately persist checkpoint for recoverability                         try { Save-Checkpoint-Atomic -State
     | $global:checkpoint } catch { Write-Log "Checkpoint save failed: $($_.Exception.Message)" -Level 'WARN' }          
     | # Append to incremental CSV when sequential                         if (-not $UseParallelProcessing) {            
     | try { $row = Build-MasterCsvRecord -Analysis $analysis; Append-IncrementalCsvRow -Row $row } catch { }            
     | }                     }                 } catch { }                  Write-Log "Completed analysis of
     | $($vault.VaultName) - Score: $($analysis.ComplianceScore)%, Risk: $($analysis.RiskLevel)" -Level "INFO"           
     | # Check if we've reached the overall limit                 if ($TestMode -and $vaultsProcessedInTestMode -ge
     | $Limit) {                     Write-Log "Test mode limit ($Limit) reached, stopping analysis" -Level "INFO"       
     | break                 }                      # Simulate an interrupt for testing if requested                    
     | if ($SimulateInterruptAfter -and $SimulateInterruptAfter -gt 0 -and $vaultsProcessedInTestMode -ge
     | $SimulateInterruptAfter) {                         Write-Log "SimulateInterruptAfter threshold reached
     | ($SimulateInterruptAfter) - saving checkpoint and setting stop flag" -Level "WARN"                        
     | $global:ScriptStopRequested = $true                         try {                             try {               
     | Save-Checkpoint-Atomic -State $global:checkpoint                                 Write-Log "Checkpoint saved to:
     | $(Get-CheckpointPath)" -Level "INFO"                             } catch {                                
     | Write-Log "Save-Checkpoint-Atomic failed: $($_.Exception.Message)" -Level 'ERROR'                             }   
     | } catch {                             Write-Log "Failed to save checkpoint during simulated interrupt:
     | $($_.Exception.Message)" -Level "ERROR"                         }                         break                   
     | }                  # Simulation: optionally trigger an interrupt after N processed vaults                 if
     | ($SimulateInterruptAfter -gt 0 -and $vaultsProcessedInTestMode -ge $SimulateInterruptAfter) {                    
     | Write-Log "SimulateInterruptAfter reached ($SimulateInterruptAfter) - simulating CTRL-C and saving checkpoint"
     | -Level 'WARN'                     $global:ScriptStopRequested = $true                     try {
     | Save-Checkpoint-Atomic -State $global:checkpoint } catch { }                     break                 }          
     | }         }          # Break out of subscription loop if overall limit reached         if ($TestMode -and
     | $vaultsProcessedInTestMode -ge $Limit) {             break         }     }      # Export CSV results     Write-Log
     | "Exporting CSV results..." -Level "INFO"     # Merge any per-worker incremental temp files into the master
     | incremental CSV (parallel-safe)     try { Merge-IncrementalTempFiles } catch { }     Write-Log "Analysis results
     | count: $($global:gapAnalysisResults.Count)" -Level "INFO"      if ($global:gapAnalysisResults -and
     | $global:gapAnalysisResults.Count -gt 0) {         # --- Normalization: QuickWins dedupe and deterministic counts
     | ---         # Ensure QuickWins titles are deduplicated (case-insensitive) per-vault         # so both CSV and HTML
     | compute totals from the same canonical set.         try {             foreach ($a in $global:gapAnalysisResults) {
     | if ($null -ne $a.QuickWins -and ($a.QuickWins -is [System.Collections.IEnumerable])) {                     # Group
     | by lowercased Title to dedupe recommendations that differ only by case                     $deduped =
     | ($a.QuickWins | Where-Object { $_.Title } | Group-Object -Property { ($_.Title -as [string]).ToLowerInvariant() }
     | | ForEach-Object { $_.Group[0] })                     $a.QuickWins = @()                     if ($deduped) {
     | $a.QuickWins = $deduped }                     # Ensure a numeric QuickWinsCount is present and deterministic      
     | try { $a.QuickWinsCount = ($a.QuickWins | Where-Object { $_.Title } | Measure-Object).Count } catch {
     | $a.QuickWinsCount = 0 }                 } else {                     $a.QuickWins = @()                    
     | $a.QuickWinsCount = 0                 }             }              # Compute global unique quick-win titles across
     | all vaults (canonicalized)             $allTitles = @()             foreach ($v in $global:gapAnalysisResults) {  
     | foreach ($w in $v.QuickWins) { if ($w.Title) { $allTitles += ($w.Title -as [string]) } }             }            
     | $uniqueWinTitles = ($allTitles | ForEach-Object { $_.Trim() } | Where-Object { $_ -and $_ -ne '' } |
     | ForEach-Object { $_.ToLowerInvariant() } | Sort-Object -Unique)             $global:TotalQuickWinsUnique =
     | ($uniqueWinTitles).Count             Write-Log "Canonical QuickWins unique titles:
     | $($global:TotalQuickWinsUnique)" -Level "INFO"         } catch {             Write-Log "QuickWins normalization
     | failed: $($_.Exception.Message)" -Level "WARN"         }          # Enrich results with additional Az CLI\Pwsh
     | data (best-effort)         Write-Log "Starting enrichment of $($global:gapAnalysisResults.Count) results with
     | Collect-ExtraAzData" -Level 'INFO'         $enrichStart = Get-Date         $enrichedResults = @()         foreach
     | ($gr in $global:gapAnalysisResults) {             try {                 Write-Log "Enriching vault:
     | $($gr.VaultName) ($($gr.Vault.ResourceId))" -Level 'INFO'                 $er = Collect-ExtraAzData -Analysis $gr 
     | $enrichedResults += $er                 Write-Log "Enriched vault: $($gr.VaultName) - done" -Level 'INFO'         
     | } catch {                 Write-Log "Collect-ExtraAzData threw for $($gr.VaultName): $($_.Exception.Message)"
     | -Level 'ERROR'                 $enrichedResults += $gr             }         }         $enrichDur = (Get-Date) -
     | $enrichStart         Write-Log "Enrichment completed for $($enrichedResults.Count) vault(s) in
     | $([math]::Round($enrichDur.TotalSeconds,2))s" -Level 'INFO'          # Progress marker file to help diagnose
     | hangs\stalls (appends latest step)         $progressFile = Join-Path -Path $env:TEMP -ChildPath
     | 'akv_gap_progress.txt'         function Write-ProgressMarker([string]$m) {             try {                 $t =
     | (Get-Date).ToString('o')                 "$t`t$m" | Out-File -FilePath $progressFile -Encoding UTF8 -Append -Force
     | } catch { }         }          # Flatten the enriched results for CSV export using the master record builder      
     | Write-Log "Starting Build-MasterCsvRecord for $($enrichedResults.Count) enriched results" -Level 'INFO'        
     | Write-ProgressMarker ("Starting Build-MasterCsvRecord for {0} enriched results" -f $enrichedResults.Count)        
     | $buildStart = Get-Date         $flattenedResults = @()         foreach ($er in $enrichedResults) {             try
     | {                 $id = ''                 try { $id = $er.VaultName -as [string] } catch { $id =
     | ($er.Vault.ResourceId -as [string]) }                 Write-Log "Building CSV record for: $id" -Level 'INFO'      
     | $row = Build-MasterCsvRecord -Analysis $er                 if ($row -ne $null) { $flattenedResults += $row;
     | Write-Log "Built CSV record for: $id" -Level 'INFO'; Write-ProgressMarker ("Built CSV record for: {0}" -f $id) }
     | else { Write-Log "Build-MasterCsvRecord returned null for: $id" -Level 'WARN'; Write-ProgressMarker
     | ("Build-MasterCsvRecord returned null for: {0}" -f $id) }             } catch {                 Write-Log ("Error
     | building CSV record for {0}: {1}" -f $id, ($_.Exception.Message -as [string])) -Level 'ERROR'             }       
     | }         $buildDur = (Get-Date) - $buildStart         Write-Log "Build-MasterCsvRecord completed for
     | $($flattenedResults.Count) records in $([math]::Round($buildDur.TotalSeconds,2))s" -Level 'INFO'          # Final
     | coercion pass: build a safe, new PSCustomObject per row so we don't try to set properties         # on values that
     | may be immutable or missing properties. This also makes exported CSVs stable.         try {             # Allow
     | test-time override of the final coercion timeout and heartbeat via env vars or global vars.            
     | $finalCoercionTimeout = 60             if ($env:FINAL_COERCION_TIMEOUT) {                 try {
     | $finalCoercionTimeout = [int]$env:FINAL_COERCION_TIMEOUT } catch { }             } elseif
     | ($global:FinalCoercionTimeoutSeconds) {                 try { $finalCoercionTimeout =
     | [int]$global:FinalCoercionTimeoutSeconds } catch { }             }             $finalCoercionHeartbeat = 5        
     | if ($env:FINAL_COERCION_HEARTBEAT) {                 try { $finalCoercionHeartbeat =
     | [int]$env:FINAL_COERCION_HEARTBEAT } catch { }             } elseif ($global:FinalCoercionHeartbeatSeconds) {     
     | try { $finalCoercionHeartbeat = [int]$global:FinalCoercionHeartbeatSeconds } catch { }             }             
     | Write-Log "Final coercion timeout set to ${finalCoercionTimeout}s (heartbeat ${finalCoercionHeartbeat}s)" -Level
     | 'DEBUG'              # To avoid Start-Job serialization issues with complex Az\PSObject types,             # write
     | the flattened results to a temporary JSON file and pass the file             # path to the background job. The job
     | will read and parse the JSON which             # avoids attempting to serialize CLR types across runspaces.       
     | $finalCoercionTemp = Join-Path -Path $env:TEMP -ChildPath ("akv_final_coercion_{0}.json" -f
     | ([guid]::NewGuid().ToString()))             # Normalize flattenedResults: drop obvious primitives or
     | empty\zero-property items to avoid coercion confusion             try {                 $preCount = 0; if
     | ($flattenedResults) { $preCount = $flattenedResults.Count }             } catch { $preCount = 0 }             try
     | {                 $flattenedResults = @($flattenedResults | Where-Object { $_ -and ( ($_ -is [PSObject]) -or ($_
     | -is [hashtable]) ) -and ($_.PSObject.Properties.Count -gt 0) })             } catch { }             try {
     | $filteredCount = $flattenedResults.Count } catch { $filteredCount = 0 }             Write-Log "Final coercion:
     | filtered flattenedResults $preCount -> $filteredCount (dropped non-object\empty rows)" -Level 'DEBUG'            
     | try {                 $flattenedResults | ConvertTo-Json -Depth 10 -Compress | Out-File -FilePath
     | $finalCoercionTemp -Encoding UTF8 -Force                 Write-ProgressMarker ("WROTE_FINAL_COERCION_TEMP {0}
     | count={1}" -f $finalCoercionTemp, $filteredCount)             } catch {                 # Fallback: try a lower
     | depth if conversion fails                 try { $flattenedResults | ConvertTo-Json -Depth 6 | Out-File -FilePath
     | $finalCoercionTemp -Encoding UTF8 -Force; Write-ProgressMarker ("WROTE_FINAL_COERCION_TEMP (fallback depth6) {0}
     | count={1}" -f $finalCoercionTemp, $filteredCount) } catch { Write-ProgressMarker
     | ("FAILED_WRITE_FINAL_COERCION_TEMP {0}" -f $finalCoercionTemp) }             }              $finalCoercionScript =
     | {                 param($rowsOrPath)                 # If the caller passed a file path, read JSON from disk to
     | obtain rows                 $rows = $null                 try {                     if ($rowsOrPath -is [string]
     | -and (Test-Path $rowsOrPath)) {                         $txt = Get-Content -Path $rowsOrPath -Raw -ErrorAction
     | Stop                         try { $rows = $txt | ConvertFrom-Json -ErrorAction Stop } catch { $rows = @() }      
     | } else {                         $rows = $rowsOrPath                     }                 } catch {              
     | $rows = @()                 }                 # Testing hook: if FORCE_FINAL_COERCION env var is set, sleep inside
     | # the timed scriptblock long enough to guarantee the heartbeat                 # wrapper will time out and trigger
     | the diagnostic writer.                 try {                     if ($env:FORCE_FINAL_COERCION -and
     | $env:FORCE_FINAL_COERCION -ne '') {                         $baseTimeout = 60                         if
     | ($env:FINAL_COERCION_TIMEOUT) {                             try { $baseTimeout = [int]$env:FINAL_COERCION_TIMEOUT
     | } catch { }                         }                         $sleepSec = $baseTimeout + 10                       
     | if ($env:FORCE_FINAL_COERCION_SLEEP) {                             try { $sleepSec =
     | [int]$env:FORCE_FINAL_COERCION_SLEEP } catch { }                         }                         Write-Output
     | "FORCE_FINAL_COERCION detected: sleeping ${sleepSec}s to trigger final-coercion timeout"                        
     | Start-Sleep -Seconds $sleepSec                     }                 } catch {                     # swallow
     | test-hook failures so they don't affect main logic                 }                 $localFinal = @()            
     | $diagMsgs = @()                 # Normalize incoming rows: ensure we have a flat array of objects to iterate      
     | $rowsToProcess = @()                 try {                     if ($null -eq $rows) {                        
     | $rowsToProcess = @()                     } elseif ($rows -is [System.Collections.IEnumerable] -and -not ($rows -is
     | [string])) {                         foreach ($r in $rows) { $rowsToProcess += $r }                     } else {  
     | $rowsToProcess += $rows                     }                 } catch {                     # fallback: wrap as
     | single element                     $rowsToProcess = @($rows)                 }                 # Add optional
     | bounds and progress logging for in-process runs                 $rowIndex = 0                 $coercionStart =
     | Get-Date                 $maxRows = $null                 $maxSeconds = $null                 if
     | ($env:FINAL_COERCION_MAX_ROWS) { try { $maxRows = [int]$env:FINAL_COERCION_MAX_ROWS } catch { $maxRows = $null } }
     | if ($env:FINAL_COERCION_MAX_SECONDS) { try { $maxSeconds = [int]$env:FINAL_COERCION_MAX_SECONDS } catch {
     | $maxSeconds = $null } }                 # In-process guard: maximum seconds to allow synchronous coercion (0 =
     | unlimited)                 $inprocessMaxSec = 0                 if ($env:FINAL_COERCION_INPROCESS_MAX_SECONDS) {
     | try { $inprocessMaxSec = [int]$env:FINAL_COERCION_INPROCESS_MAX_SECONDS } catch { $inprocessMaxSec = 0 } }        
     | # Allow skipping per-vault JSON writes when running in-process for faster runs                
     | $disablePerVaultJson = $false                 if ($env:DISABLE_PER_VAULT_JSON -and $env:DISABLE_PER_VAULT_JSON -ne
     | '') { $disablePerVaultJson = $true }                 if ($rowsToProcess.Count -eq 0) { Write-Log "[COERCION] No
     | rows to process in final coercion" -Level 'DEBUG' }                 foreach ($orig in $rowsToProcess) {           
     | $rowIndex++                     if ($rowIndex % 10 -eq 0) {                         $elapsed = (Get-Date) -
     | $coercionStart                         Write-Log "[COERCION] Processing row $rowIndex of $($rowsToProcess.Count)
     | (elapsed: $([math]::Round($elapsed.TotalSeconds,1))s)" -Level 'DEBUG'                     }                     #
     | Respect optional bounds to avoid unbounded synchronous runs                     if ($maxRows -and $rowIndex -gt
     | $maxRows) {                         $diagMsgs += ("Stopped coercion after {0} rows due to FINAL_COERCION_MAX_ROWS"
     | -f $maxRows)                         break                     }                     if ($maxSeconds) {           
     | $elapsed = (Get-Date) - $coercionStart                         if ($elapsed.TotalSeconds -gt $maxSeconds) {       
     | $diagMsgs += ("Stopped coercion after {0}s due to FINAL_COERCION_MAX_SECONDS" -f $maxSeconds)                     
     | break                         }                     }                      # Per-row diagnostics: type and prop
     | count                     $rowStart = Get-Date                     try { $rowType = if ($null -eq $orig) { 'Null'
     | } else { $orig.GetType().FullName } } catch { $rowType = 'Unknown' }                     try { $propCount = if
     | ($orig -and $orig.PSObject -and $orig.PSObject.Properties) { $orig.PSObject.Properties.Count } else { 0 } } catch
     | { $propCount = 0 }                     Write-Log "[COERCION] Row #$rowIndex type=$rowType propCount=$propCount
     | VaultName='$($orig.VaultName -as [string])'" -Level 'DEBUG'                      # If the incoming element looks
     | like a primitive (no properties and is value type\string), coerce into hashtable                     if
     | ($propCount -eq 0 -and ($orig -is [string] -or $orig -is [System.ValueType] -or $rowType -eq 'System.Boolean')) { 
     | try {                             $co = [ordered]@{}                             $co['Value'] = ($orig -as
     | [string]) ?? ''                             $orig = [PSCustomObject]$co                             Write-Log
     | "[COERCION] Coerced non-object row #$rowIndex to PSCustomObject" -Level 'DEBUG'                         } catch { 
     | $errMsg = $_.Exception.Message                             Write-Log ("[COERCION] Failed to coerce non-object row
     | #{0}: {1}" -f $rowIndex, $errMsg) -Level 'WARN'                         }                     }                   
     | # Start with an ordered hashtable copy of existing properties when possible                     $props =
     | [ordered]@{}                     try {                         foreach ($p in $orig.PSObject.Properties) {        
     | $val = $p.Value                             # Flatten arrays to string for CSV                             if
     | ($val -is [System.Collections.IEnumerable] -and -not ($val -is [string])) {                                 try {
     | $val = ($val | ForEach-Object { $_.ToString() }) -join '; ' } catch { $val = $val.ToString() }                    
     | }                             $props[$p.Name] = $val                         }                         Write-Log
     | "[COERCION] Processed props for $($orig.VaultName -as [string]): $($props | Out-String)" -Level 'DEBUG'           
     | } catch {                         $props['Value'] = ($orig -as [string]) ?? ''                         Write-Log
     | "[COERCION] Failed to process props for $($orig): $($_.Exception.Message)" -Level 'ERROR'                     }   
     | # Helper to safely read from $props (local)                     function Get-PropValueLocal([hashtable]$h,
     | [string]$name) {                         if ($h.ContainsKey($name)) { return $h[$name] } else { return $null }    
     | }                      try {                         # Coerce RoleAssignmentsResolved to a predictable string     
     | $rawRole = Get-PropValueLocal $props 'RoleAssignmentsResolved'                         if ($null -eq $rawRole) {  
     | $props['RoleAssignmentsResolved'] = ''                         } elseif ($rawRole -is [string]) {                 
     | $props['RoleAssignmentsResolved'] = $rawRole                         } elseif ($rawRole -is
     | [System.Collections.IEnumerable]) {                             $parts = @()                             foreach
     | ($elem in $rawRole) {                                 if ($null -eq $elem) { continue }                           
     | if ($elem -is [PSObject] -or $elem -is [hashtable]) {                                     try { $parts +=
     | (ConvertTo-Json $elem -Depth 2 -Compress) } catch { $parts += $elem.ToString() }                                 }
     | else { $parts += $elem.ToString() }                             }                            
     | $props['RoleAssignmentsResolved'] = ($parts | Where-Object { $_ -and $_ -ne '' }) -join '; '                      
     | } else {                             $props['RoleAssignmentsResolved'] = ($rawRole -as [string]) ?? ''            
     | }                     } catch {                         $props['RoleAssignmentsResolved'] = ''                    
     | }                      # Coerce VaultScore to int scalar                     try {                         $vs =
     | Get-PropValueLocal $props 'VaultScore'                         $cs = Get-PropValueLocal $props 'ComplianceScore'  
     | $props['VaultScore'] = ($vs -as [int]) ?? ($cs -as [int]) ?? 0                     } catch {                      
     | $props['VaultScore'] = (Get-PropValueLocal $props 'ComplianceScore' -as [int]) ?? 0                     }         
     | # Ensure JsonFilePath is string                     $props['JsonFilePath'] = (Get-PropValueLocal $props
     | 'JsonFilePath' -as [string]) ?? ''                      # If a per-vault JSON path exists, write a compact vault
     | JSON using the coerced scalars                     try {                         $jsonPath =
     | $props['JsonFilePath']                         if (-not $disablePerVaultJson -and $jsonPath -and $jsonPath -ne '')
     | {                             $vaultExport = [ordered]@{                                 Timestamp =
     | (Get-Date).ToString('o')                                 SubscriptionId = (Get-PropValueLocal $props
     | 'SubscriptionId' -as [string]) ?? ''                                 SubscriptionName = (Get-PropValueLocal $props
     | 'SubscriptionName' -as [string]) ?? ''                                 VaultName = (Get-PropValueLocal $props
     | 'VaultName' -as [string]) ?? ''                                 VaultResourceId = (Get-PropValueLocal $props
     | 'VaultResourceId' -as [string]) ?? ''                                 Location = (Get-PropValueLocal $props
     | 'Location' -as [string]) ?? ''                                 ComplianceScore = (Get-PropValueLocal $props
     | 'ComplianceScore' -as [int]) ?? 0                                 VaultScore = ($props['VaultScore'] -as [int]) ??
     | 0                                 RoleAssignmentsResolved = ($props['RoleAssignmentsResolved'] -as [string]) ?? ''
     | ManagedIdentityResolved = (Get-PropValueLocal $props 'ManagedIdentityResolved' -as [string]) ?? ''                
     | DiagnosticDestinationNames = (Get-PropValueLocal $props 'DiagnosticDestinationNames' -as [string]) ?? ''          
     | SkuName = (Get-PropValueLocal $props 'SkuName' -as [string]) ?? ''                                
     | SecretRotationMostRecent = (Get-PropValueLocal $props 'SecretRotationMostRecent' -as [string]) ?? ''              
     | KeyRotationMostRecent = (Get-PropValueLocal $props 'KeyRotationMostRecent' -as [string]) ?? ''                    
     | JsonFilePath = $jsonPath                             }                             try {                          
     | Write-ProgressMarker ("ATTEMPT_PER_VAULT_JSON {0}" -f $jsonPath)                                 # Use a simple
     | Out-File for per-vault JSON to avoid atomic helpers that may block on special filesystems                         
     | $vaultExport | ConvertTo-Json -Depth 4 | Out-File -FilePath $jsonPath -Encoding UTF8 -Force                       
     | Write-ProgressMarker ("WROTE_PER_VAULT_JSON {0}" -f $jsonPath)                             } catch {              
     | Write-Log "[COERCION] Failed to write per-vault JSON for $($props['VaultName'] -as [string]):
     | $($_.Exception.Message)" -Level 'DEBUG'                                 Write-ProgressMarker
     | ("FAILED_PER_VAULT_JSON {0} err={1}" -f $jsonPath, ($_.Exception.Message -replace '\r|\n',' '))                   
     | }                         }                     } catch {                         # ignore failures to write
     | per-vault JSON - CSV should still be the authoritative output                     }                      # Record
     | a small diagnostic message for the caller                     try {                         $vn =
     | (Get-PropValueLocal $props 'VaultName' -as [string]) ?? ''                         $diagMsgs += ("Processed vault:
     | {0}" -f $vn)                     } catch { }                      try {                         if ($props -is
     | [hashtable]) {                             $localFinal += [PSCustomObject]$props                         } else { 
     | # Ensure we always have some representation                             try { $localFinal += [PSCustomObject]@{
     | Value = ($orig -as [string]) ?? '' } } catch { }                             Write-Log "[COERCION] Skipped
     | non-hashtable props for $($orig.VaultName -as [string])" -Level 'ERROR'                         }                 
     | } catch {                         Write-Log "[COERCION] Failed to cast props to PSCustomObject for
     | $($orig.VaultName -as [string]): $($_.Exception.Message)" -Level 'ERROR'                     }                    
     | # Check total elapsed time for in-process guard                     if ($inprocessMaxSec -gt 0) {                 
     | $elapsed = (Get-Date) - $coercionStart                         if ($elapsed.TotalSeconds -ge $inprocessMaxSec) {  
     | Write-Log "[COERCION] Aborting in-process final coercion after $([math]::Round($elapsed.TotalSeconds,1))s
     | (max=${inprocessMaxSec}s)" -Level 'WARN'                             $diagMsgs += ("Aborted in-process after
     | processing $rowIndex rows due to FINAL_COERCION_INPROCESS_MAX_SECONDS")                             break         
     | }                     }                     # Per-row duration debug (only if slow)                     $rowDur =
     | (Get-Date) - $rowStart                     if ($rowDur.TotalSeconds -gt 1) {                         Write-Log
     | "[COERCION] Slow row #$rowIndex processed in $([math]::Round($rowDur.TotalSeconds,2))s" -Level 'DEBUG'            
     | }                 }                  return @{ Results = $localFinal; Messages = $diagMsgs }             }        
     | # Decide whether to run final coercion in a timed background job or inline.             # Default: use background
     | job (Invoke-WithHeartbeat). But for small\test runs             # prefer in-process to avoid Start-Job
     | serialization issues and command-line limits.             $inprocessLimit = 3             if
     | ($env:FINAL_COERCION_INPROCESS_LIMIT) { try { $inprocessLimit = [int]$env:FINAL_COERCION_INPROCESS_LIMIT } catch {
     | $inprocessLimit = 3 } }              $shouldForceInProcess = $false             if ($env:FORCE_FINAL_COERCION_MODE
     | -and ($env:FORCE_FINAL_COERCION_MODE -ieq 'inprocess' -or $env:FORCE_FINAL_COERCION_MODE -ieq 'local')) {
     | $shouldForceInProcess = $true }             if ($global:ForceInProcessFinalCoercion) { $shouldForceInProcess =
     | $true }             # If running TestMode or processing only a small number of vaults (Limit), prefer in-process  
     | try {                 if ($TestMode) { $shouldForceInProcess = $true }                 if (($Limit -as [int]) -ne
     | $null) { if ($Limit -le $inprocessLimit) { $shouldForceInProcess = $true } }             } catch { }             
     | if ($shouldForceInProcess) {                 Write-Log "Running final coercion synchronously in-process
     | (shouldForceInProcess=$shouldForceInProcess)" -Level 'WARN'                 # When running coercion in-process,
     | avoid per-vault JSON writes which may                 # hang on slow filesystems (OneDrive, network mounts) or
     | cause long IO.                 Write-Log "Disabling per-vault JSON writes for in-process final coercion" -Level
     | 'DEBUG'                 $env:DISABLE_PER_VAULT_JSON = '1'                 try {                     $invokeResult
     | = & $finalCoercionScript $finalCoercionTemp                 } catch {                     throw                 }
     | finally {                     # restore env var if previously unset                     try { Remove-Item
     | Env:DISABLE_PER_VAULT_JSON -ErrorAction SilentlyContinue } catch { }                 }             } else {       
     | $invokeResult = Invoke-WithHeartbeat -ScriptBlock $finalCoercionScript -Args @($finalCoercionTemp) -TimeoutSeconds
     | $finalCoercionTimeout -HeartbeatSeconds $finalCoercionHeartbeat -Description 'Final coercion & per-vault JSON
     | writes'             }             # Cleanup temp file (best-effort)             try { if (Test-Path
     | $finalCoercionTemp) { Remove-Item -Path $finalCoercionTemp -Force -ErrorAction SilentlyContinue } } catch {}      
     | # Unpack invoke result and log diagnostic messages             $finalResults = @()             if ($invokeResult
     | -and $invokeResult.Results) { $finalResults = $invokeResult.Results }             try {                 if
     | ($invokeResult -and $invokeResult.Messages) {                     foreach ($m in $invokeResult.Messages) {
     | Write-Log $m -Level 'DEBUG' }                 }             } catch { }         } catch {             Write-Log
     | "Final coercion step timed out or errored: $($_.Exception.Message)" -Level 'ERROR'             # If job-based
     | invocation failed due to Start-Job serialization of complex objects,             # attempt an in-process fallback
     | to perform the same coercion logic synchronously.             if ($_.Exception.Message -and ($_.Exception.Message
     | -match 'Cannot convert the "System.Object\[\]" value')) {                 Write-Log "Detected Start-Job
     | serialization error; attempting in-process final coercion fallback" -Level 'WARN'                 try {           
     | $localFinalFb = @()                     $diagMsgsFb = @()                     foreach ($orig in $flattenedResults)
     | {                         try {                             $propsFb = [ordered]@{}                            
     | foreach ($p in $orig.PSObject.Properties) {                                 $val = $p.Value                       
     | if ($val -is [System.Collections.IEnumerable] -and -not ($val -is [string])) {                                    
     | try { $val = ($val | ForEach-Object { $_.ToString() }) -join '; ' } catch { $val = $val.ToString() }              
     | }                                 $propsFb[$p.Name] = $val                             }                         }
     | catch {                             $propsFb['Value'] = ($orig -as [string]) ?? ''                         }      
     | # Coerce RoleAssignmentsResolved                         try {                             $rawRole =
     | $propsFb['RoleAssignmentsResolved']                             if ($null -eq $rawRole) {
     | $propsFb['RoleAssignmentsResolved'] = '' }                             elseif ($rawRole -is [string]) {
     | $propsFb['RoleAssignmentsResolved'] = $rawRole }                             elseif ($rawRole -is
     | [System.Collections.IEnumerable]) {                                 $parts = @()                                
     | foreach ($elem in $rawRole) {                                     if ($null -eq $elem) { continue }               
     | if ($elem -is [PSObject] -or $elem -is [hashtable]) {                                         try { $parts +=
     | (ConvertTo-Json $elem -Depth 2 -Compress) } catch { $parts += $elem.ToString() }                                  
     | } else { $parts += $elem.ToString() }                                 }                                
     | $propsFb['RoleAssignmentsResolved'] = ($parts | Where-Object { $_ -and $_ -ne '' }) -join '; '                    
     | } else { $propsFb['RoleAssignmentsResolved'] = ($rawRole -as [string]) ?? '' }                         } catch {
     | $propsFb['RoleAssignmentsResolved'] = '' }                          # VaultScore                         try {    
     | $vs = $propsFb['VaultScore']; $cs = $propsFb['ComplianceScore']                             $propsFb['VaultScore']
     | = ($vs -as [int]) ?? ($cs -as [int]) ?? 0                         } catch { $propsFb['VaultScore'] =
     | ($propsFb['ComplianceScore'] -as [int]) ?? 0 }                          # JsonFilePath                        
     | $propsFb['JsonFilePath'] = ($propsFb['JsonFilePath'] -as [string]) ?? ''                          # Write
     | per-vault JSON if requested                         try {                             $jsonPathFb =
     | $propsFb['JsonFilePath']                             if ($jsonPathFb -and $jsonPathFb -ne '') {                   
     | $vaultExportFb = [ordered]@{                                     Timestamp = (Get-Date).ToString('o')             
     | SubscriptionId = ($propsFb['SubscriptionId'] -as [string]) ?? ''                                    
     | SubscriptionName = ($propsFb['SubscriptionName'] -as [string]) ?? ''                                     VaultName
     | = ($propsFb['VaultName'] -as [string]) ?? ''                                     VaultResourceId =
     | ($propsFb['VaultResourceId'] -as [string]) ?? ''                                     Location =
     | ($propsFb['Location'] -as [string]) ?? ''                                     ComplianceScore =
     | ($propsFb['ComplianceScore'] -as [int]) ?? 0                                     VaultScore =
     | ($propsFb['VaultScore'] -as [int]) ?? 0                                     RoleAssignmentsResolved =
     | ($propsFb['RoleAssignmentsResolved'] -as [string]) ?? ''                                     JsonFilePath =
     | $jsonPathFb                                 }                                 try { Write-AtomicJson -Path
     | $jsonPathFb -Object $vaultExportFb -Depth 4 } catch { }                             }                         }
     | catch { }                          $diagMsgsFb += ("Processed vault: {0}" -f (($propsFb['VaultName'] -as [string])
     | ?? ''))                         try { $localFinalFb += [PSCustomObject]$propsFb } catch { }                     } 
     | $invokeResult = @{ Results = $localFinalFb; Messages = $diagMsgsFb }                     $finalResults =
     | $invokeResult.Results                     Write-Log "In-process final coercion fallback succeeded" -Level 'INFO'  
     | } catch {                     Write-Log "In-process final coercion fallback also failed: $($_.Exception.Message)"
     | -Level 'ERROR'                 }             }             try {                 $diagPath = Join-Path -Path
     | $outputDir -ChildPath ("final_coercion_diag_{0}.txt" -f (Get-Date).ToString('yyyy-MM-dd_HH-mm-ss'))               
     | $diag = [ordered]@{                     Timestamp = (Get-Date).ToString('o')                     Error =
     | ($_.Exception.Message)                     FlattenedCount = ($flattenedResults.Count)                    
     | FirstVaults = ($flattenedResults | Select-Object -First 20 | ForEach-Object { ($_).VaultName } | Where-Object { $_
     | } ) -join '; '                 }                 $diag | Out-File -FilePath $diagPath -Encoding UTF8              
     | Write-Log "Wrote final coercion diagnostic to: $diagPath" -Level 'INFO'                     Write-ProgressMarker
     | ("WROTE_FINAL_COERCION_DIAG {0}" -f $diagPath)                  # Also write a fuller diagnostic into the
     | repository workspace for easier inspection by developers                 try {                     $repoBase =
     | Split-Path -Path $MyInvocation.MyCommand.Definition -Parent -ErrorAction SilentlyContinue                     if
     | (-not $repoBase -or $repoBase -eq '') { $repoBase = Get-Location }                     $repoOutputDir = Join-Path
     | -Path $repoBase 'output'                     if (-not (Test-Path $repoOutputDir)) { New-Item -ItemType Directory
     | -Path $repoOutputDir -Force | Out-Null }                     $repoDiagPath = Join-Path -Path $repoOutputDir
     | -ChildPath ("final_coercion_diag_full_{0}.json" -f (Get-Date).ToString('yyyy-MM-dd_HH-mm-ss'))                    
     | try {                         $sample = $flattenedResults | Select-Object -First 50                        
     | $sample | ConvertTo-Json -Depth 8 | Out-File -FilePath $repoDiagPath -Encoding UTF8 -Force                        
     | Write-Log "Wrote extended final coercion diagnostic to workspace: $repoDiagPath" -Level 'INFO'                    
     | Write-ProgressMarker ("WROTE_FINAL_COERCION_FULL {0}" -f $repoDiagPath)                     } catch {             
     | Write-Log "Failed to write extended final coercion diagnostic to workspace: $($_.Exception.Message)" -Level 'WARN'
     | }                 } catch {                     # non-fatal                 }             } catch {               
     | Write-Log "Failed to write final coercion diagnostic: $($_.Exception.Message)" -Level 'WARN'             }        
     | # Continue to HTML generation despite final coercion failure         }          # Recompute canonical unique
     | QuickWins now (ensure it's up-to-date before HTML generation)         try {             $allWinTitles = @()       
     | foreach ($v in $global:gapAnalysisResults) { foreach ($w in ($v.QuickWins)) { if ($w.Title) { $allWinTitles +=
     | $w.Title } } }             $uniqueWinTitles = @()             if ($allWinTitles.Count -gt 0) {                
     | $uniqueWinTitles = ($allWinTitles | ForEach-Object { $_.Trim() } | Where-Object { $_ -and $_ -ne '' } |
     | ForEach-Object { $_.ToLowerInvariant() } | Sort-Object -Unique)             }             $global:uniqueWinTitles
     | = $uniqueWinTitles             $global:TotalQuickWinsUnique = ($uniqueWinTitles).Count         } catch {          
     | $global:uniqueWinTitles = @()             $global:TotalQuickWinsUnique = 0         }          # Pre-export parity
     | check: ensure canonical unique QuickWins (computed earlier) matches parsed QuickWinsSummary         try {         
     | $parsedTitles = @()             foreach ($row in $finalResults) {                 if ($row.QuickWinsSummary -and
     | $row.QuickWinsSummary.Trim() -ne '') {                     $parts = $row.QuickWinsSummary -split ';' |
     | ForEach-Object { $_.Trim() } | Where-Object { $_ -ne '' }                     $parsedTitles += $parts             
     | }             }             $parsedUnique = ($parsedTitles | ForEach-Object { $_.ToLowerInvariant() } |
     | Sort-Object -Unique)             $parsedCount = ($parsedUnique).Count             if ($global:TotalQuickWinsUnique
     | -ne $parsedCount) {                 Write-Log "Pre-export parity check failed: canonical unique quick wins
     | ($($global:TotalQuickWinsUnique)) != parsed quick wins from CSV data ($parsedCount)" -Level "WARN"                
     | # Write a small reconciliation file to workspace for debugging                 try {                    
     | $reconPath = Join-Path -Path (Split-Path -Path $csvPath -Parent) -ChildPath
     | "quickwins_reconciliation_$((Get-Date).ToString('yyyy-MM-dd_HH-mm-ss')).csv"                     $reconObj =
     | [PSCustomObject]@{                         CanonicalCount = $global:TotalQuickWinsUnique                        
     | ParsedCount = $parsedCount                         CanonicalTitles = ($uniqueWinTitles -join '; ')                
     | ParsedTitles = ($parsedUnique -join '; ')                     }                     $reconObj | Export-Csv -Path
     | $reconPath -NoTypeInformation -Encoding UTF8                     Write-Log "Wrote quick-wins reconciliation to:
     | $reconPath" -Level "INFO"                 } catch {                     Write-Log "Failed to write quick-wins
     | reconciliation file: $($_.Exception.Message)" -Level "WARN"                 }             } else {                
     | Write-Log "Pre-export parity check: canonical quick wins ($($global:TotalQuickWinsUnique)) == parsed quick wins
     | ($parsedCount)" -Level "INFO"             }         } catch {             Write-Log "Pre-export parity check
     | encountered an error: $($_.Exception.Message)" -Level "WARN"         }          Write-Log "Starting final CSV
     | export to: $csvPath" -Level "INFO"         # Use background job with heartbeat and timeout to detect IO
     | stalls\hangs         $csvTimeout = $global:CsvExportTimeoutSeconds         if (-not $csvTimeout -or $csvTimeout
     | -le 0) { $csvTimeout = 600 } # default 10 minutes         try {             # Ensure a stable, canonical column
     | order for CSV exports.             # Prefer an existing template CSV header (most recent
     | KeyVaultComprehensiveAudit_*.csv in script dir) if available,             # otherwise use the union of property
     | names from the final results.             $scriptDir = Split-Path -Path $MyInvocation.MyCommand.Definition -Parent
     | $templateCsv = Get-ChildItem -Path $scriptDir -Filter 'KeyVaultComprehensiveAudit_*.csv' -File -ErrorAction
     | SilentlyContinue | Sort-Object LastWriteTime -Descending | Select-Object -First 1             if ($templateCsv) { 
     | try {                     $headerLine = (Get-Content -Path $templateCsv.FullName -TotalCount 1 -ErrorAction Stop) 
     | $headerLine = $headerLine.Trim()                     if ($headerLine.StartsWith('"') -and
     | $headerLine.EndsWith('"')) { $headerLine = $headerLine.TrimStart('"').TrimEnd('"') }                    
     | $preferredHeaders = $headerLine -split '","'                 } catch {                     $preferredHeaders = @()
     | }             } else {                 $preferredHeaders = @()             }              if (-not
     | $preferredHeaders -or $preferredHeaders.Count -eq 0) {                 # Fall back to union of properties found in
     | the results (stable alphabetical order)                 $preferredHeaders = $finalResults | ForEach-Object {
     | $_.PSObject.Properties.Name } | Sort-Object -Unique             }              # Select objects with the preferred
     | header order; missing properties will be emitted as empty fields.             $exportSelection = $preferredHeaders
     | $toExport = $finalResults | Select-Object -Property $exportSelection             $toExport | Export-Csv -Path
     | $csvPath -NoTypeInformation -Encoding UTF8 -Force             Write-Log "CSV export finished (file: $csvPath)"
     | -Level 'SUCCESS'             Write-Log "HTML Report: $htmlPath" -Level "INFO"             Write-Log "CSV Data:
     | $csvPath" -Level "INFO"         } catch {             Write-Log "CSV export FAILED: $($_.Exception.Message)"
     | -Level "ERROR"             throw         }     } else {         Write-Log "No analysis results to export" -Level
     | "WARNING"         # Create empty CSV with headers         $emptyResult = [PSCustomObject]@{            
     | SubscriptionId = ""             VaultName = ""             Location = ""             ComplianceScore = 0          
     | RiskLevel = ""             SecurityGapsCount = 0             QuickWinsCount = 0         }         $emptyResult |
     | Export-Csv -Path $csvPath -NoTypeInformation -Encoding UTF8     }      # Generate HTML report     # Generate HTML
     | in a child pwsh process with a timeout to avoid blocking the main run     $timeoutSec =
     | $global:HtmlGenerationTimeoutSeconds     if (-not $timeoutSec -or $timeoutSec -le 0) { $timeoutSec = 120 }    
     | Write-Log "Generating HTML report in child process (timeout ${timeoutSec}s)..." -Level "INFO"     # Avoid spawning
     | the child HTML generator during focused SingleVault TestMode runs to prevent     # script re-entry and long
     | re-discovery. Spawn the child only for broader runs.     if (-not $script:PreventChildHtmlSpawn) {         try {  
     | $scriptFullPath = $MyInvocation.MyCommand.Definition             $tempDataPath = Join-Path -Path $env:TEMP
     | -ChildPath ("akv_gap_html_data_$([guid]::NewGuid()).json")             $tempPlatformPath = Join-Path -Path
     | $env:TEMP -ChildPath ("akv_gap_platform_$([guid]::NewGuid()).json")              try {                 Write-Log
     | "Serializing analysis results for child HTML generation..." -Level 'INFO'                 Write-ProgressMarker
     | ("START_NORMALIZE_FOR_JSON count={0}" -f ($global:gapAnalysisResults.Count))                 $normResults =
     | Normalize-ForJson $global:gapAnalysisResults                 # Instrument serialization time                
     | $serializeSw = [System.Diagnostics.Stopwatch]::StartNew()                 $serialized = $null                 try
     | {                     $opts = New-Object System.Text.Json.JsonSerializerOptions                    
     | $opts.WriteIndented = $false                     $serialized =
     | [System.Text.Json.JsonSerializer]::Serialize($normResults, $opts)                     $serialized | Out-File
     | -FilePath $tempDataPath -Encoding UTF8 -Force                     $serializeSw.Stop()                     $serT =
     | [math]::Round($serializeSw.Elapsed.TotalSeconds,2)                     Write-Log "Serialized analysis results
     | using System.Text.Json -> $tempDataPath (took ${serT}s)" -Level 'INFO'                     Write-ProgressMarker
     | ("SERIALIZED_SYSTEM_TEXT_JSON {0} took={1}s" -f $tempDataPath, $serT)                 } catch {                   
     | $serializeSw.Stop()                     try {                         $serT =
     | [math]::Round($serializeSw.Elapsed.TotalSeconds,2)                         Write-Log "System.Text.Json serialize
     | failed after ${serT}s, falling back to ConvertTo-Json: $($_.Exception.Message)" -Level 'WARN'                     
     | Write-ProgressMarker ("SYSTEM_TEXT_JSON_FAILED took={0}s err={1}" -f $serT, ($_.Exception.Message -replace
     | '\r|\n',' '))                         $normResults | ConvertTo-Json -Depth 6 | Out-File -FilePath $tempDataPath
     | -Encoding UTF8 -Force                         Write-Log "Serialized analysis results using ConvertTo-Json ->
     | $tempDataPath" -Level 'INFO'                         Write-ProgressMarker ("SERIALIZED_CONVERTTOJSON {0}" -f
     | $tempDataPath)                     } catch {                         Write-Log "Failed to serialize analysis
     | results for child HTML generation: $($_.Exception.Message)" -Level "WARN"                        
     | Write-ProgressMarker ("FAILED_SERIALIZE_FOR_HTML err={0}" -f ($_.Exception.Message -replace '\r|\n',' '))         
     | $tempDataPath = ''                     }                 }             } catch {                 Write-Log "Failed
     | to prepare analysis results for HTML generation: $($_.Exception.Message)" -Level 'WARN'                
     | Write-ProgressMarker ("FAILED_PREPARE_ANALYSIS_FOR_HTML err={0}" -f ($_.Exception.Message -replace '\r|\n',' '))  
     | $tempDataPath = ''             }              try {                 $normPlatform = Normalize-ForJson
     | $platformAssessments                 $normPlatform | ConvertTo-Json -Depth 8 | Out-File -FilePath
     | $tempPlatformPath -Encoding UTF8             } catch {                 Write-Log "Failed to serialize platform
     | assessments for child HTML generation: $($_.Exception.Message)" -Level "WARN"                 $tempPlatformPath =
     | ''             }              # Launch the child script using a small temporary wrapper script which sets         
     | # environment variables for the large JSON paths and then invokes the             # main script with a short
     | argument list. This avoids Windows command-line             # length limits when passing long argument strings.   
     | try {                 $guid = [guid]::NewGuid().ToString()                 $wrapperPath = Join-Path -Path
     | $env:TEMP -ChildPath ("akv_html_launcher_{0}.ps1" -f $guid)                 $wrapperStdOut = Join-Path -Path
     | $env:TEMP -ChildPath ("akv_html_child_stdout_{0}.log" -f $guid)                 $wrapperStdErr = Join-Path -Path
     | $env:TEMP -ChildPath ("akv_html_child_stderr_{0}.log" -f $guid)                 $wrapperContent = @()             
     | # Set env vars inside the wrapper so the child can read them without long args                 $escapedData =
     | $tempDataPath -replace "'","''"                 $escapedPlatform = $tempPlatformPath -replace "'","''"            
     | $escapedHtml = $htmlPath -replace "'","''"                 $wrapperContent += "`$env:AKV_HTML_DATA_PATH =
     | '$escapedData'"                 $wrapperContent += "`$env:AKV_HTML_PLATFORM_PATH = '$escapedPlatform'"            
     | # Child output log paths                 $wrapperContent += "`$env:AKV_HTML_CHILD_STDOUT = '$wrapperStdOut'"      
     | $wrapperContent += "`$env:AKV_HTML_CHILD_STDERR = '$wrapperStdErr'"                 $wrapperContent += "# Invoke
     | the main script in HTML-only mode; short arg list. Capture stdout\stderr to temp files."                 # Use
     | explicit stream redirection so parent can inspect child logs later                 $invokeLine = "& pwsh
     | -NoProfile -File '$scriptFullPath' -AKV_HTML_ONLY -AKV_HTML_OUTPUT_PATH '$escapedHtml' 1> '$wrapperStdOut' 2>
     | '$wrapperStdErr'; exit `$LASTEXITCODE"                 $wrapperContent += $invokeLine                
     | $wrapperContent | Out-File -FilePath $wrapperPath -Encoding UTF8 -Force                 Write-ProgressMarker
     | ("WROTE_HTML_WRAPPER {0}" -f $wrapperPath)                  Write-Log "Spawning child HTML generator via wrapper:
     | $wrapperPath" -Level 'DEBUG'                 try { $pwshExe = (Get-Command pwsh -ErrorAction
     | SilentlyContinue).Source } catch { $pwshExe = 'pwsh' }                 if (-not $pwshExe) { $pwshExe = 'pwsh' }   
     | Write-ProgressMarker ("STARTING_CHILD_PROCESS exe={0} wrapper={1}" -f $pwshExe, $wrapperPath)                
     | $proc = Start-Process -FilePath $pwshExe -ArgumentList @('-NoProfile','-File',$wrapperPath) -PassThru -WindowStyle
     | Hidden             } catch {                 throw             }             # Instrument child process runtime to
     | identify hangs with heartbeat logging             $procStart = Get-Date             $procSw =
     | [System.Diagnostics.Stopwatch]::StartNew()             $heartbeat = 15             if
     | ($global:HtmlGenerationHeartbeatSeconds -and ($global:HtmlGenerationHeartbeatSeconds -as [int]) -gt 0) {
     | $heartbeat = [int]$global:HtmlGenerationHeartbeatSeconds }             $elapsed = 0             try {             
     | while (-not $proc.HasExited) {                     if ($proc.WaitForExit($heartbeat * 1000)) { break }            
     | $elapsed = [math]::Round($procSw.Elapsed.TotalSeconds,1)                     Write-Log "HTML generation still
     | running after ${elapsed}s (heartbeat every ${heartbeat}s)" -Level 'INFO'                     if
     | ($procSw.Elapsed.TotalSeconds -ge $timeoutSec) {                         Write-Log "HTML generation timed out
     | after ${timeoutSec}s; terminating child process (ran ${elapsed}s)" -Level 'WARN'                         try {
     | $proc.Kill() } catch { Write-Log "Failed to kill HTML generator process: $($_.Exception.Message)" -Level 'ERROR' }
     | break                     }                 }                 $procSw.Stop()                 if ($proc.HasExited)
     | {                     Write-Log "Child HTML generator exited (exitCode $($proc.ExitCode)) in
     | $(([math]::Round($procSw.Elapsed.TotalSeconds, 2)))s" -Level "INFO"                     Write-ProgressMarker
     | ("CHILD_EXITED exitCode={0} elapsed={1}s" -f $proc.ExitCode, [math]::Round($procSw.Elapsed.TotalSeconds,2))       
     | } else {                     Write-Log "Child HTML generator did not exit cleanly; it was terminated after
     | $(([math]::Round($procSw.Elapsed.TotalSeconds,2)))s" -Level "WARN"                     Write-ProgressMarker
     | ("CHILD_TERMINATED elapsed={0}s" -f [math]::Round($procSw.Elapsed.TotalSeconds,2))                 }             }
     | catch {                 Write-Log "Error while waiting for child HTML generator: $($_.Exception.Message)" -Level
     | 'ERROR'             }             # If the wrapper created child stdout\stderr files, copy them to the CSV\HTML
     | output folder for diagnosis             try {                 $childLogDestDir = $null                 if
     | ($csvPath) { $childLogDestDir = Split-Path -Path $csvPath -Parent }                 if (-not $childLogDestDir) {
     | $childLogDestDir = Split-Path -Path $MyInvocation.MyCommand.Definition -Parent }                 if (Test-Path
     | -Path $wrapperStdOut) {                     $destOut = Join-Path -Path $childLogDestDir -ChildPath
     | ("child_html_stdout_{0}.log" -f $guid)                     Copy-Item -Path $wrapperStdOut -Destination $destOut
     | -Force -ErrorAction SilentlyContinue                     Write-Log "Child HTML STDOUT saved to: $destOut" -Level
     | 'DEBUG'                     Write-ProgressMarker ("COPIED_CHILD_STDOUT {0}" -f $destOut)                 }        
     | if (Test-Path -Path $wrapperStdErr) {                     $destErr = Join-Path -Path $childLogDestDir -ChildPath
     | ("child_html_stderr_{0}.log" -f $guid)                     Copy-Item -Path $wrapperStdErr -Destination $destErr
     | -Force -ErrorAction SilentlyContinue                     Write-Log "Child HTML STDERR saved to: $destErr" -Level
     | 'DEBUG'                     Write-ProgressMarker ("COPIED_CHILD_STDERR {0}" -f $destErr)                 }        
     | } catch {                 Write-Log "Failed copying child HTML log files for diagnosis: $($_.Exception.Message)"
     | -Level 'WARN'             }             # If the child was terminated due to timeout, write a placeholder HTML so
     | users still get an artifact             if ($proc -and -not $proc.HasExited -and $proc.ExitCode -eq $null) {      
     | # If process still exists and exit code unknown, assume it was terminated by us due to timeout                
     | $placeholder = "<!DOCTYPE html><html><head><meta charset='utf-8'><title>HTML generation timed
     | out<\title><\head><body><h1>HTML generation timed out after ${timeoutSec}s<\h1><p>The full HTML report was not
     | generated. Check logs for details.<\p><\body><\html>"                 try {                     $placeholder |
     | Out-File -FilePath $htmlPath -Encoding UTF8                     Write-Log "Wrote placeholder HTML to $htmlPath"
     | -Level "WARN"                 } catch {                     Write-Log "Failed to write placeholder HTML:
     | $($_.Exception.Message)" -Level "ERROR"                 }             }              # Cleanup temp JSON files    
     | try { if ($tempDataPath -and (Test-Path $tempDataPath)) { Remove-Item -Path $tempDataPath -Force -ErrorAction
     | SilentlyContinue } } catch {}             try { if ($tempPlatformPath -and (Test-Path $tempPlatformPath)) {
     | Remove-Item -Path $tempPlatformPath -Force -ErrorAction SilentlyContinue } } catch {}         } catch {           
     | Write-Log "Failed to spawn child HTML generator: $($_.Exception.Message)" -Level "ERROR"         }     } else {   
     | Write-Log "Skipping HTML child generation due to PreventChildHtmlSpawn flag (SingleVault+TestMode) to avoid
     | re-entry" -Level 'INFO'     }      # Post-run: copy CSV and HTML into repository workspace for easier inspection
     | (best-effort)     try {         # Prefer PSScriptRoot when running as a script; fallback to MyInvocation path when
     | necessary         $repoBase = $PSScriptRoot         if (-not $repoBase -or $repoBase -eq '') {            
     | $repoBase = Split-Path -Path $MyInvocation.MyCommand.Definition -Parent -ErrorAction SilentlyContinue         }   
     | if (-not $repoBase -or $repoBase -eq '') { throw 'Unable to determine repository base path for workspace copy' }  
     | $repoOutputDir = Join-Path $repoBase 'output'         if (!(Test-Path $repoOutputDir)) { New-Item -ItemType
     | Directory -Path $repoOutputDir -Force | Out-Null }         $repoCsv = Join-Path $repoOutputDir (Split-Path -Path
     | $csvPath -Leaf)         $repoHtml = Join-Path $repoOutputDir (Split-Path -Path $htmlPath -Leaf)         # Copy CSV
     | try {             Write-Log "Copying CSV to workspace: $repoCsv" -Level "INFO"             Copy-Item -Path
     | $csvPath -Destination $repoCsv -Force -ErrorAction Stop             Write-Log "Copied CSV to workspace: $repoCsv"
     | -Level "INFO"         } catch {             Write-Log "Failed to copy CSV to workspace: $($_.Exception.Message)"
     | -Level "WARN"         }          # Copy HTML if present         try {             if (Test-Path $htmlPath) {      
     | Write-Log "Copying HTML to workspace: $repoHtml" -Level "INFO"                 Copy-Item -Path $htmlPath
     | -Destination $repoHtml -Force -ErrorAction Stop                 Write-Log "Copied HTML to workspace: $repoHtml"
     | -Level "INFO"             } else {                 Write-Log "HTML path not found, skipping workspace copy:
     | $htmlPath" -Level "INFO"             }         } catch {             Write-Log "Failed to copy HTML to workspace:
     | $($_.Exception.Message)" -Level "WARN"         }         Write-Log "Workspace copy attempts completed
     | (best-effort) to: $repoOutputDir" -Level "INFO"     } catch {         # Non-fatal if copy fails (e.g., permissions
     | or path issues) - continue silently     }      # Restore any altered global preferences (best-effort)     try {   
     | if (Get-Variable -Name __prevWarningPreference -Scope Script -ErrorAction SilentlyContinue) {            
     | $WarningPreference = $script:__prevWarningPreference             Remove-Variable -Name __prevWarningPreference
     | -Scope Script -ErrorAction SilentlyContinue         }     } catch { }      # Summary     $endTime = Get-Date    
     | $duration = $endTime - $StartTime      Write-Log "Gap analysis completed successfully!" -Level "SUCCESS"    
     | Write-Log "Total vaults analyzed: $totalVaultsAnalyzed" -Level "INFO"     Write-Log "Execution time:
     | $([math]::Round($duration.TotalMinutes, 1)) minutes" -Level "INFO"     Write-Log "Results saved to: $outputDir"
     | -Level "INFO"     Write-Log "HTML Report: $htmlPath" -Level "INFO"     Write-Log "CSV Data: $csvPath" -Level
     | "INFO"     Write-Log "Log File: $logPath" -Level "INFO"      # Cleanup run lock (best-effort) so future runs can
     | start     if (-not $NoRunLock) {         if ($script:RunLockPath -and (Test-Path $script:RunLockPath)) {          
     | try {                 $rawLock = Get-Content -Path $script:RunLockPath -ErrorAction SilentlyContinue -Raw         
     | $meta = $null                 if ($rawLock -and $rawLock.Trim() -ne '') {                 try {                   
     | $meta = $rawLock | ConvertFrom-Json -ErrorAction SilentlyContinue                 } catch {                    
     | $meta = $null                 }             }                 $shouldRemove = $false                 if ($meta
     | -and $meta.PID) {                     if ($meta.PID -eq $PID) { $shouldRemove = $true }                 } else {  
     | # Unknown metadata - attempt removal                     $shouldRemove = $true                 }                
     | if ($shouldRemove) {                         Remove-Item -Path $script:RunLockPath -Force -ErrorAction
     | SilentlyContinue                         Write-Log "Removed run lock: $script:RunLockPath" -Level 'INFO'          
     | } else {                     Write-Log "Did not remove run lock ($script:RunLockPath) owned by PID $($meta.PID)"
     | -Level 'DEBUG'                 }             } catch {                 # fallback: attempt remove                
     | Remove-Item -Path $script:RunLockPath -Force -ErrorAction SilentlyContinue             }         }     } else {   
     | Write-Log "NoRunLock was set for this run; skipping run-lock cleanup." -Level 'DEBUG'     }     catch {         #
     | non-fatal     }     # Clear in-process sentinel     try {         $global:AkvGapAnalysis_InProcessRun = $false    
     | } catch {     } ' is too long, or a component of the specified path is too long.

PS>TerminatingError(Get-ChildItem): "A parameter cannot be found that matches parameter name 'File'."
[2025-10-28 13:12:17] [ERROR]   CSV export FAILED: A parameter cannot be found that matches parameter name 'File'.
PS>TerminatingError(Get-ChildItem): "A parameter cannot be found that matches parameter name 'File'."
[2025-10-28 13:12:17] [WARN]    Invoke-GapAnalysis called while another run is active in this process (PID: 42848) - skipping nested invocation. CallStack: 
Command                  Arguments                                                          Location
-------                  ---------                                                          --------
Invoke-GapAnalysis       {}                                                                 Get-AKVGapAnalysis.ps1: line …
Get-AKVGapAnalysis.ps1   {TestMode=True, Limit=1, Verbose=True, SuppressAzureWarnings=True} Get-AKVGapAnalysis.ps1: line …
run_testmode_wrapper.ps1 {}                                                                 run_testmode_wrapper.ps1: lin…
**********************
PowerShell transcript end
End time: 20251028131217
**********************
